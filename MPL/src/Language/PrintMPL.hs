{-# LANGUAGE CPP #-}
#if __GLASGOW_HASKELL__ <= 708
{-# LANGUAGE OverlappingInstances #-}
#endif
{-# LANGUAGE FlexibleInstances #-}
{-# OPTIONS_GHC -fno-warn-incomplete-patterns #-}

-- | Pretty-printer for Language.
--   Generated by the BNF converter.

module Language.PrintMPL where

import qualified Language.AbsMPL
import Data.Char

-- | The top-level printing method.

printTree :: Print a => a -> String
printTree = render . prt 0

type Doc = [ShowS] -> [ShowS]

doc :: ShowS -> Doc
doc = (:)

render :: Doc -> String
render d = rend 0 (map ($ "") $ d []) "" where
  rend i ss = case ss of
    "["      :ts -> showChar '[' . rend i ts
    "("      :ts -> showChar '(' . rend i ts
    "{"      :ts -> showChar '{' . new (i+1) . rend (i+1) ts
    "}" : ";":ts -> new (i-1) . space "}" . showChar ';' . new (i-1) . rend (i-1) ts
    "}"      :ts -> new (i-1) . showChar '}' . new (i-1) . rend (i-1) ts
    ";"      :ts -> showChar ';' . new i . rend i ts
    t  : ts@(p:_) | closingOrPunctuation p -> showString t . rend i ts
    t        :ts -> space t . rend i ts
    _            -> id
  new i   = showChar '\n' . replicateS (2*i) (showChar ' ') . dropWhile isSpace
  space t = showString t . (\s -> if null s then "" else ' ':s)

  closingOrPunctuation :: String -> Bool
  closingOrPunctuation [c] = c `elem` closerOrPunct
  closingOrPunctuation _   = False

  closerOrPunct :: String
  closerOrPunct = ")],;"

parenth :: Doc -> Doc
parenth ss = doc (showChar '(') . ss . doc (showChar ')')

concatS :: [ShowS] -> ShowS
concatS = foldr (.) id

concatD :: [Doc] -> Doc
concatD = foldr (.) id

replicateS :: Int -> ShowS -> ShowS
replicateS n f = concatS (replicate n f)

-- | The printer class does the job.

class Print a where
  prt :: Int -> a -> Doc
  prtList :: Int -> [a] -> Doc
  prtList i = concatD . map (prt i)

instance {-# OVERLAPPABLE #-} Print a => Print [a] where
  prt = prtList

instance Print Char where
  prt _ s = doc (showChar '\'' . mkEsc '\'' s . showChar '\'')
  prtList _ s = doc (showChar '"' . concatS (map (mkEsc '"') s) . showChar '"')

mkEsc :: Char -> Char -> ShowS
mkEsc q s = case s of
  _ | s == q -> showChar '\\' . showChar s
  '\\'-> showString "\\\\"
  '\n' -> showString "\\n"
  '\t' -> showString "\\t"
  _ -> showChar s

prPrec :: Int -> Int -> Doc -> Doc
prPrec i j = if j < i then parenth else id

instance Print Integer where
  prt _ x = doc (shows x)

instance Print Double where
  prt _ x = doc (shows x)

instance Print Language.AbsMPL.UIdent where
  prt _ (Language.AbsMPL.UIdent (_,i)) = doc (showString i)

instance Print Language.AbsMPL.PIdent where
  prt _ (Language.AbsMPL.PIdent (_,i)) = doc (showString i)
  prtList _ [] = concatD []
  prtList _ [x] = concatD [prt 0 x]
  prtList _ (x:xs) = concatD [prt 0 x, doc (showString ","), prt 0 xs]

instance Print Language.AbsMPL.PInteger where
  prt _ (Language.AbsMPL.PInteger (_,i)) = doc (showString i)

instance Print Language.AbsMPL.Infixl1op where
  prt _ (Language.AbsMPL.Infixl1op i) = doc (showString i)

instance Print Language.AbsMPL.Infixl2op where
  prt _ (Language.AbsMPL.Infixl2op i) = doc (showString i)

instance Print Language.AbsMPL.Infixl3op where
  prt _ (Language.AbsMPL.Infixl3op i) = doc (showString i)

instance Print Language.AbsMPL.Infixl4op where
  prt _ (Language.AbsMPL.Infixl4op i) = doc (showString i)

instance Print Language.AbsMPL.Infixl5op where
  prt _ (Language.AbsMPL.Infixl5op i) = doc (showString i)

instance Print Language.AbsMPL.Infixl6op where
  prt _ (Language.AbsMPL.Infixl6op i) = doc (showString i)

instance Print Language.AbsMPL.Infixr7op where
  prt _ (Language.AbsMPL.Infixr7op i) = doc (showString i)

instance Print Language.AbsMPL.Infixl8op where
  prt _ (Language.AbsMPL.Infixl8op i) = doc (showString i)

instance Print [Language.AbsMPL.PIdent] where
  prt = prtList

instance Print Language.AbsMPL.MplProg where
  prt i e = case e of
    Language.AbsMPL.MPL_PROG mplstmts -> prPrec i 0 (concatD [prt 0 mplstmts])

instance Print Language.AbsMPL.MplStmt where
  prt i e = case e of
    Language.AbsMPL.MPL_DEFN_STMS_WHERE mpldefns mplstmts -> prPrec i 0 (concatD [doc (showString "defn"), doc (showString "{"), prt 0 mpldefns, doc (showString "}"), doc (showString "where"), doc (showString "{"), prt 0 mplstmts, doc (showString "}")])
    Language.AbsMPL.MPL_DEFN_STMS mpldefns -> prPrec i 0 (concatD [doc (showString "defn"), doc (showString "{"), prt 0 mpldefns, doc (showString "}")])
    Language.AbsMPL.MPL_STMT mpldefn -> prPrec i 0 (concatD [prt 0 mpldefn])
  prtList _ [] = concatD []
  prtList _ (x:xs) = concatD [prt 0 x, prt 0 xs]

instance Print [Language.AbsMPL.MplDefn] where
  prt = prtList

instance Print [Language.AbsMPL.MplStmt] where
  prt = prtList

instance Print Language.AbsMPL.MplDefn where
  prt i e = case e of
    Language.AbsMPL.MPL_SEQUENTIAL_TYPE_DEFN sequentialtypedefn -> prPrec i 0 (concatD [prt 0 sequentialtypedefn])
    Language.AbsMPL.MPL_CONCURRENT_TYPE_DEFN concurrenttypedefn -> prPrec i 0 (concatD [prt 0 concurrenttypedefn])
    Language.AbsMPL.MPL_FUNCTION_DEFN functiondefn -> prPrec i 0 (concatD [prt 0 functiondefn])
    Language.AbsMPL.MPL_PROCESS_DEFN processdefn -> prPrec i 0 (concatD [prt 0 processdefn])
    Language.AbsMPL.MPLDEFNTEST -> prPrec i 0 (concatD [doc (showString "potato")])
  prtList _ [x] = concatD [prt 0 x]
  prtList _ (x:xs) = concatD [prt 0 x, doc (showString ";"), prt 0 xs]

instance Print Language.AbsMPL.MplType where
  prt i e = case e of
    Language.AbsMPL.MPL_TYPE mpltype -> prPrec i 0 (concatD [prt 0 mpltype])
    Language.AbsMPL.PAR_TYPE mpltype1 mpltype2 -> prPrec i 0 (concatD [prt 1 mpltype1, doc (showString "(+)"), prt 1 mpltype2])
    Language.AbsMPL.TENSOR_TYPE mpltype1 mpltype2 -> prPrec i 1 (concatD [prt 2 mpltype1, doc (showString "(*)"), prt 2 mpltype2])
    Language.AbsMPL.GETPUT_TYPE uident mpltype1 mpltype2 -> prPrec i 2 (concatD [prt 0 uident, doc (showString "("), prt 0 mpltype1, doc (showString "|"), prt 0 mpltype2, doc (showString ")")])
    Language.AbsMPL.MPL_UIDENT_ARGS_TYPE uident mpltypes -> prPrec i 3 (concatD [prt 0 uident, doc (showString "("), prt 0 mpltypes, doc (showString ")")])
    Language.AbsMPL.MPL_UIDENT_NO_ARGS_TYPE uident -> prPrec i 3 (concatD [prt 0 uident])
    Language.AbsMPL.MPL_UNIT_TYPE -> prPrec i 3 (concatD [doc (showString "("), doc (showString ")")])
    Language.AbsMPL.MPL_BRACKETED_TYPE mpltype -> prPrec i 3 (concatD [doc (showString "("), prt 0 mpltype, doc (showString ")")])
    Language.AbsMPL.MPL_LIST_TYPE mpltype -> prPrec i 3 (concatD [doc (showString "["), prt 0 mpltype, doc (showString "]")])
    Language.AbsMPL.MPL_TUPLE_TYPE mpltype tuplelisttypes -> prPrec i 3 (concatD [doc (showString "("), prt 0 mpltype, doc (showString ","), prt 0 tuplelisttypes, doc (showString ")")])
  prtList _ [] = concatD []
  prtList _ [x] = concatD [prt 0 x]
  prtList _ (x:xs) = concatD [prt 0 x, doc (showString ","), prt 0 xs]

instance Print Language.AbsMPL.TupleListType where
  prt i e = case e of
    Language.AbsMPL.TUPLE_LIST_TYPE mpltype -> prPrec i 0 (concatD [prt 0 mpltype])
  prtList _ [x] = concatD [prt 0 x]
  prtList _ (x:xs) = concatD [prt 0 x, doc (showString ","), prt 0 xs]

instance Print [Language.AbsMPL.TupleListType] where
  prt = prtList

instance Print [Language.AbsMPL.MplType] where
  prt = prtList

instance Print Language.AbsMPL.SequentialTypeDefn where
  prt i e = case e of
    Language.AbsMPL.DATA_DEFN seqtypeclausedefns -> prPrec i 0 (concatD [doc (showString "data"), prt 0 seqtypeclausedefns])
    Language.AbsMPL.CODATA_DEFN seqtypeclausedefns -> prPrec i 0 (concatD [doc (showString "codata"), prt 0 seqtypeclausedefns])

instance Print Language.AbsMPL.SeqTypeClauseDefn where
  prt i e = case e of
    Language.AbsMPL.SEQ_TYPE_CLAUSE mpltype1 mpltype2 seqtypephrasedefns -> prPrec i 0 (concatD [prt 0 mpltype1, doc (showString "->"), prt 0 mpltype2, doc (showString "="), doc (showString "{"), prt 0 seqtypephrasedefns, doc (showString "}")])
  prtList _ [x] = concatD [prt 0 x]
  prtList _ (x:xs) = concatD [prt 0 x, doc (showString "and"), prt 0 xs]

instance Print Language.AbsMPL.SeqTypePhraseDefn where
  prt i e = case e of
    Language.AbsMPL.SEQ_TYPE_PHRASE typehandlenames mpltypes mpltype -> prPrec i 0 (concatD [prt 0 typehandlenames, doc (showString "::"), prt 0 mpltypes, doc (showString "->"), prt 0 mpltype])
  prtList _ [] = concatD []
  prtList _ [x] = concatD [prt 0 x]
  prtList _ (x:xs) = concatD [prt 0 x, doc (showString ";"), prt 0 xs]

instance Print [Language.AbsMPL.SeqTypeClauseDefn] where
  prt = prtList

instance Print [Language.AbsMPL.SeqTypePhraseDefn] where
  prt = prtList

instance Print Language.AbsMPL.ConcurrentTypeDefn where
  prt i e = case e of
    Language.AbsMPL.PROTOCOL_DEFN concurrenttypeclausedefns -> prPrec i 0 (concatD [doc (showString "protocol"), prt 0 concurrenttypeclausedefns])
    Language.AbsMPL.COPROTOCOL_DEFN concurrenttypeclausedefns -> prPrec i 0 (concatD [doc (showString "coprotocol"), prt 0 concurrenttypeclausedefns])

instance Print Language.AbsMPL.ConcurrentTypeClauseDefn where
  prt i e = case e of
    Language.AbsMPL.CONCURRENT_TYPE_CLAUSE mpltype1 mpltype2 concurrenttypephrasedefns -> prPrec i 0 (concatD [prt 0 mpltype1, doc (showString "=>"), prt 0 mpltype2, doc (showString "="), doc (showString "{"), prt 0 concurrenttypephrasedefns, doc (showString "}")])
  prtList _ [x] = concatD [prt 0 x]
  prtList _ (x:xs) = concatD [prt 0 x, doc (showString "and"), prt 0 xs]

instance Print Language.AbsMPL.ConcurrentTypePhraseDefn where
  prt i e = case e of
    Language.AbsMPL.CONCURRENT_TYPE_PHRASE typehandlenames mpltype1 mpltype2 -> prPrec i 0 (concatD [prt 0 typehandlenames, doc (showString "::"), prt 0 mpltype1, doc (showString "=>"), prt 0 mpltype2])
  prtList _ [] = concatD []
  prtList _ [x] = concatD [prt 0 x]
  prtList _ (x:xs) = concatD [prt 0 x, doc (showString ";"), prt 0 xs]

instance Print [Language.AbsMPL.ConcurrentTypeClauseDefn] where
  prt = prtList

instance Print [Language.AbsMPL.ConcurrentTypePhraseDefn] where
  prt = prtList

instance Print Language.AbsMPL.TypeHandleName where
  prt i e = case e of
    Language.AbsMPL.TYPE_HANDLE_NAME uident -> prPrec i 0 (concatD [prt 0 uident])
  prtList _ [x] = concatD [prt 0 x]
  prtList _ (x:xs) = concatD [prt 0 x, doc (showString ","), prt 0 xs]

instance Print [Language.AbsMPL.TypeHandleName] where
  prt = prtList

instance Print Language.AbsMPL.Expr where
  prt i e = case e of
    Language.AbsMPL.EXPR expr -> prPrec i 0 (concatD [prt 0 expr])
    Language.AbsMPL.IF_EXPR expr1 expr2 expr3 -> prPrec i 0 (concatD [doc (showString "if"), prt 0 expr1, doc (showString "then"), prt 0 expr2, doc (showString "else"), prt 0 expr3])
    Language.AbsMPL.LET_EXPR letexprphrases expr -> prPrec i 0 (concatD [doc (showString "let"), doc (showString "{"), prt 0 letexprphrases, doc (showString "}"), doc (showString "in"), prt 0 expr])
    Language.AbsMPL.INFIXR0_EXPR expr1 expr2 -> prPrec i 0 (concatD [prt 1 expr1, doc (showString ":"), prt 0 expr2])
    Language.AbsMPL.INFIXL1_EXPR expr1 infixlop expr2 -> prPrec i 1 (concatD [prt 1 expr1, prt 0 infixlop, prt 2 expr2])
    Language.AbsMPL.INFIXL2_EXPR expr1 infixlop expr2 -> prPrec i 2 (concatD [prt 2 expr1, prt 0 infixlop, prt 3 expr2])
    Language.AbsMPL.INFIXL3_EXPR expr1 infixlop expr2 -> prPrec i 3 (concatD [prt 3 expr1, prt 0 infixlop, prt 4 expr2])
    Language.AbsMPL.INFIXL4_EXPR expr1 infixlop expr2 -> prPrec i 4 (concatD [prt 4 expr1, prt 0 infixlop, prt 5 expr2])
    Language.AbsMPL.INFIXL5_EXPR expr1 infixlop expr2 -> prPrec i 5 (concatD [prt 5 expr1, prt 0 infixlop, prt 6 expr2])
    Language.AbsMPL.INFIXL6_EXPR expr1 infixlop expr2 -> prPrec i 6 (concatD [prt 6 expr1, prt 0 infixlop, prt 7 expr2])
    Language.AbsMPL.INFIXR7_EXPR expr1 infixrop expr2 -> prPrec i 7 (concatD [prt 8 expr1, prt 0 infixrop, prt 7 expr2])
    Language.AbsMPL.INFIXL8_EXPR expr1 infixlop expr2 -> prPrec i 8 (concatD [prt 8 expr1, prt 0 infixlop, prt 10 expr2])
    Language.AbsMPL.LIST_EXPR exprs -> prPrec i 10 (concatD [doc (showString "["), prt 0 exprs, doc (showString "]")])
    Language.AbsMPL.VAR_EXPR pident -> prPrec i 10 (concatD [prt 0 pident])
    Language.AbsMPL.INT_EXPR pinteger -> prPrec i 10 (concatD [prt 0 pinteger])
    Language.AbsMPL.STRING_EXPR str -> prPrec i 10 (concatD [prt 0 str])
    Language.AbsMPL.CHAR_EXPR c -> prPrec i 10 (concatD [prt 0 c])
    Language.AbsMPL.DOUBLE_EXPR d -> prPrec i 10 (concatD [prt 0 d])
    Language.AbsMPL.UNIT_EXPR -> prPrec i 10 (concatD [doc (showString "("), doc (showString ")")])
    Language.AbsMPL.FOLD_EXPR pident foldexprphrases -> prPrec i 10 (concatD [doc (showString "fold"), prt 0 pident, doc (showString "of"), doc (showString "{"), prt 0 foldexprphrases, doc (showString "}")])
    Language.AbsMPL.UNFOLD_EXPR pident unfoldexprphrases -> prPrec i 10 (concatD [doc (showString "unfold"), prt 0 pident, doc (showString "of"), doc (showString "{"), prt 0 unfoldexprphrases, doc (showString "}")])
    Language.AbsMPL.CASE_EXPR expr pattexprphrases -> prPrec i 10 (concatD [doc (showString "case"), prt 0 expr, doc (showString "of"), doc (showString "{"), prt 0 pattexprphrases, doc (showString "}")])
    Language.AbsMPL.SWITCH_EXP switchexprphrases -> prPrec i 10 (concatD [doc (showString "switch"), doc (showString "{"), prt 0 switchexprphrases, doc (showString "}")])
    Language.AbsMPL.DESTRUCTOR_CONSTRUCTOR_ARGS_EXPR uident exprs -> prPrec i 10 (concatD [prt 0 uident, doc (showString "("), prt 0 exprs, doc (showString ")")])
    Language.AbsMPL.DESTRUCTOR_CONSTRUCTOR_NO_ARGS_EXPR uident -> prPrec i 10 (concatD [prt 0 uident])
    Language.AbsMPL.TUPLE_EXPR expr tupleexprlists -> prPrec i 10 (concatD [doc (showString "("), prt 0 expr, doc (showString ","), prt 0 tupleexprlists, doc (showString ")")])
    Language.AbsMPL.FUN_EXPR pident exprs -> prPrec i 10 (concatD [prt 0 pident, doc (showString "("), prt 0 exprs, doc (showString ")")])
    Language.AbsMPL.RECORD_EXPR recordexprphrases -> prPrec i 10 (concatD [doc (showString "("), prt 0 recordexprphrases, doc (showString ")")])
  prtList _ [] = concatD []
  prtList _ [x] = concatD [prt 0 x]
  prtList _ (x:xs) = concatD [prt 0 x, doc (showString ","), prt 0 xs]

instance Print Language.AbsMPL.UnfoldExprPhrase where
  prt i e = case e of
    Language.AbsMPL.UNFOLD_EXPR_PHRASE expr foldexprphrases -> prPrec i 0 (concatD [prt 0 expr, doc (showString "of"), doc (showString "{"), prt 0 foldexprphrases, doc (showString "}")])
  prtList _ [] = concatD []
  prtList _ [x] = concatD [prt 0 x]
  prtList _ (x:xs) = concatD [prt 0 x, doc (showString ";"), prt 0 xs]

instance Print [Language.AbsMPL.UnfoldExprPhrase] where
  prt = prtList

instance Print Language.AbsMPL.FoldExprPhrase where
  prt i e = case e of
    Language.AbsMPL.FOLD_EXPR_PHRASE uident pidents expr -> prPrec i 0 (concatD [prt 0 uident, doc (showString ":"), prt 0 pidents, doc (showString "->"), prt 0 expr])
  prtList _ [] = concatD []
  prtList _ [x] = concatD [prt 0 x]
  prtList _ (x:xs) = concatD [prt 0 x, doc (showString ";"), prt 0 xs]

instance Print [Language.AbsMPL.FoldExprPhrase] where
  prt = prtList

instance Print Language.AbsMPL.LetExprPhrase where
  prt i e = case e of
    Language.AbsMPL.LET_EXPR_PHRASE mplstmt -> prPrec i 0 (concatD [prt 0 mplstmt])
  prtList _ [x] = concatD [prt 0 x]
  prtList _ (x:xs) = concatD [prt 0 x, doc (showString ";"), prt 0 xs]

instance Print [Language.AbsMPL.LetExprPhrase] where
  prt = prtList

instance Print Language.AbsMPL.TupleExprList where
  prt i e = case e of
    Language.AbsMPL.TUPLE_EXPR_LIST expr -> prPrec i 0 (concatD [prt 0 expr])
  prtList _ [x] = concatD [prt 0 x]
  prtList _ (x:xs) = concatD [prt 0 x, doc (showString ","), prt 0 xs]

instance Print [Language.AbsMPL.TupleExprList] where
  prt = prtList

instance Print Language.AbsMPL.RecordExprPhrase where
  prt i e = case e of
    Language.AbsMPL.RECORD_EXPR_PHRASE uident expr -> prPrec i 0 (concatD [prt 0 uident, doc (showString ":="), prt 0 expr])
  prtList _ [x] = concatD [prt 0 x]
  prtList _ (x:xs) = concatD [prt 0 x, doc (showString ","), prt 0 xs]

instance Print [Language.AbsMPL.RecordExprPhrase] where
  prt = prtList

instance Print Language.AbsMPL.SwitchExprPhrase where
  prt i e = case e of
    Language.AbsMPL.SWITCH_EXPR_PHRASE expr1 expr2 -> prPrec i 0 (concatD [prt 0 expr1, doc (showString "->"), prt 0 expr2])
  prtList _ [x] = concatD [prt 0 x]
  prtList _ (x:xs) = concatD [prt 0 x, doc (showString ";"), prt 0 xs]

instance Print [Language.AbsMPL.SwitchExprPhrase] where
  prt = prtList

instance Print [Language.AbsMPL.Expr] where
  prt = prtList

instance Print Language.AbsMPL.PattExprPhrase where
  prt i e = case e of
    Language.AbsMPL.PATTERN_TO_EXPR patterns expr -> prPrec i 0 (concatD [prt 0 patterns, doc (showString "->"), prt 0 expr])
  prtList _ [x] = concatD [prt 0 x]
  prtList _ (x:xs) = concatD [prt 0 x, doc (showString ";"), prt 0 xs]

instance Print Language.AbsMPL.Pattern where
  prt i e = case e of
    Language.AbsMPL.PATTERN pattern -> prPrec i 0 (concatD [prt 0 pattern])
    Language.AbsMPL.LIST_COLON_PATTERN pattern1 pattern2 -> prPrec i 0 (concatD [prt 1 pattern1, doc (showString ":"), prt 0 pattern2])
    Language.AbsMPL.CONSTRUCTOR_PATTERN_ARGS uident patterns -> prPrec i 1 (concatD [prt 0 uident, doc (showString "("), prt 0 patterns, doc (showString ")")])
    Language.AbsMPL.CONSTRUCTOR_PATTERN_NO_ARGS uident -> prPrec i 1 (concatD [prt 0 uident])
    Language.AbsMPL.UNIT_PATTERN -> prPrec i 1 (concatD [doc (showString "("), doc (showString ")")])
    Language.AbsMPL.RECORD_PATTERN destructorpatternphrase destructorpatternphrases -> prPrec i 1 (concatD [doc (showString "("), prt 0 destructorpatternphrase, doc (showString ","), prt 0 destructorpatternphrases, doc (showString ")")])
    Language.AbsMPL.LIST_PATTERN patterns -> prPrec i 1 (concatD [doc (showString "["), prt 0 patterns, doc (showString "]")])
    Language.AbsMPL.TUPLE_PATTERN pattern tuplelistpatterns -> prPrec i 1 (concatD [doc (showString "("), prt 0 pattern, doc (showString ","), prt 0 tuplelistpatterns, doc (showString ")")])
    Language.AbsMPL.VAR_PATTERN pident -> prPrec i 1 (concatD [prt 0 pident])
    Language.AbsMPL.STR_PATTERN str -> prPrec i 1 (concatD [prt 0 str])
    Language.AbsMPL.INT_PATTERN pinteger -> prPrec i 1 (concatD [prt 0 pinteger])
    Language.AbsMPL.NULL_PATTERN -> prPrec i 1 (concatD [doc (showString "_")])
  prtList _ [] = concatD []
  prtList _ [x] = concatD [prt 0 x]
  prtList _ (x:xs) = concatD [prt 0 x, doc (showString ","), prt 0 xs]

instance Print [Language.AbsMPL.Pattern] where
  prt = prtList

instance Print Language.AbsMPL.TupleListPattern where
  prt i e = case e of
    Language.AbsMPL.TUPLE_LIST_PATTERN pattern -> prPrec i 0 (concatD [prt 0 pattern])
  prtList _ [x] = concatD [prt 0 x]
  prtList _ (x:xs) = concatD [prt 0 x, doc (showString ","), prt 0 xs]

instance Print [Language.AbsMPL.TupleListPattern] where
  prt = prtList

instance Print Language.AbsMPL.DestructorPatternPhrase where
  prt i e = case e of
    Language.AbsMPL.DESTRUCTOR_PATTERN_PHRASE uident pattern -> prPrec i 0 (concatD [prt 0 uident, doc (showString ":="), prt 0 pattern])
  prtList _ [x] = concatD [prt 0 x]
  prtList _ (x:xs) = concatD [prt 0 x, doc (showString ","), prt 0 xs]

instance Print [Language.AbsMPL.DestructorPatternPhrase] where
  prt = prtList

instance Print Language.AbsMPL.FunctionDefn where
  prt i e = case e of
    Language.AbsMPL.TYPED_FUNCTION_DEFN pident mpltypes mpltype pattexprphrases -> prPrec i 0 (concatD [doc (showString "fun"), prt 0 pident, doc (showString "::"), prt 0 mpltypes, doc (showString "->"), prt 0 mpltype, doc (showString "="), doc (showString "{"), prt 0 pattexprphrases, doc (showString "}")])
    Language.AbsMPL.FUNCTION_DEFN pident pattexprphrases -> prPrec i 0 (concatD [doc (showString "fun"), prt 0 pident, doc (showString "="), doc (showString "{"), prt 0 pattexprphrases, doc (showString "}")])

instance Print [Language.AbsMPL.PattExprPhrase] where
  prt = prtList

instance Print Language.AbsMPL.ProcessDefn where
  prt i e = case e of
    Language.AbsMPL.TYPED_PROCESS_DEFN pident mpltypes1 mpltypes2 mpltypes3 processphrases -> prPrec i 0 (concatD [doc (showString "proc"), prt 0 pident, doc (showString "::"), prt 0 mpltypes1, doc (showString "|"), prt 0 mpltypes2, doc (showString "=>"), prt 0 mpltypes3, doc (showString "="), doc (showString "{"), prt 0 processphrases, doc (showString "}")])
    Language.AbsMPL.PROCESS_DEFN pident processphrases -> prPrec i 0 (concatD [doc (showString "proc"), prt 0 pident, doc (showString "="), doc (showString "{"), prt 0 processphrases, doc (showString "}")])

instance Print Language.AbsMPL.ProcessPhrase where
  prt i e = case e of
    Language.AbsMPL.PROCESS_PHRASE patterns pidents1 pidents2 processcommandsblock -> prPrec i 0 (concatD [prt 0 patterns, doc (showString "|"), prt 0 pidents1, doc (showString "=>"), prt 0 pidents2, doc (showString "->"), prt 0 processcommandsblock])
  prtList _ [] = concatD []
  prtList _ [x] = concatD [prt 0 x]
  prtList _ (x:xs) = concatD [prt 0 x, doc (showString ";"), prt 0 xs]

instance Print [Language.AbsMPL.ProcessPhrase] where
  prt = prtList

instance Print Language.AbsMPL.ProcessCommandsBlock where
  prt i e = case e of
    Language.AbsMPL.PROCESS_COMMANDS_DO_BLOCK processcommands -> prPrec i 0 (concatD [doc (showString "do"), doc (showString "{"), prt 0 processcommands, doc (showString "}")])
    Language.AbsMPL.PROCESS_COMMANDS_SINGLE_COMMAND_BLOCK processcommand -> prPrec i 0 (concatD [prt 0 processcommand])

instance Print [Language.AbsMPL.ProcessCommand] where
  prt = prtList

instance Print Language.AbsMPL.ProcessCommand where
  prt i e = case e of
    Language.AbsMPL.PROCESS_RUN pident exprs pidents1 pidents2 -> prPrec i 0 (concatD [prt 0 pident, doc (showString "("), prt 0 exprs, doc (showString "|"), prt 0 pidents1, doc (showString "=>"), prt 0 pidents2, doc (showString ")")])
    Language.AbsMPL.PROCESS_CLOSE pident -> prPrec i 0 (concatD [doc (showString "close"), prt 0 pident])
    Language.AbsMPL.PROCESS_HALT pident -> prPrec i 0 (concatD [doc (showString "halt"), prt 0 pident])
    Language.AbsMPL.PROCESS_GET pident1 pident2 -> prPrec i 0 (concatD [doc (showString "get"), prt 0 pident1, doc (showString "on"), prt 0 pident2])
    Language.AbsMPL.PROCESS_PUT expr pident -> prPrec i 0 (concatD [doc (showString "put"), prt 0 expr, doc (showString "on"), prt 0 pident])
    Language.AbsMPL.PROCESS_HCASE pident hcasephrases -> prPrec i 0 (concatD [doc (showString "hcase"), prt 0 pident, doc (showString "of"), doc (showString "{"), prt 0 hcasephrases, doc (showString "}")])
    Language.AbsMPL.PROCESS_HPUT uident pident -> prPrec i 0 (concatD [doc (showString "hput"), prt 0 uident, doc (showString "on"), prt 0 pident])
    Language.AbsMPL.PROCESS_SPLIT pident pidents -> prPrec i 0 (concatD [doc (showString "split"), prt 0 pident, doc (showString "into"), prt 0 pidents])
    Language.AbsMPL.PROCESS_FORK pident forkphrases -> prPrec i 0 (concatD [doc (showString "fork"), prt 0 pident, doc (showString "as"), doc (showString "{"), prt 0 forkphrases, doc (showString "}")])
    Language.AbsMPL.PROCESS_ID pident1 pident2 -> prPrec i 0 (concatD [prt 0 pident1, doc (showString "|=|"), prt 0 pident2])
    Language.AbsMPL.PROCESS_NEG pident1 pident2 -> prPrec i 0 (concatD [prt 0 pident1, doc (showString "|=|"), doc (showString "neg"), prt 0 pident2])
    Language.AbsMPL.PROCESS_RACE racephrases -> prPrec i 0 (concatD [doc (showString "race"), doc (showString "{"), prt 0 racephrases, doc (showString "}")])
    Language.AbsMPL.PROCESS_PLUG plugphrases -> prPrec i 0 (concatD [doc (showString "plug"), doc (showString "{"), prt 0 plugphrases, doc (showString "}")])
    Language.AbsMPL.PROCESS_CASE expr processcasephrases -> prPrec i 0 (concatD [doc (showString "case"), prt 0 expr, doc (showString "of"), doc (showString "{"), prt 0 processcasephrases, doc (showString "}")])
    Language.AbsMPL.PROCESS_SWITCH processswitchphrases -> prPrec i 0 (concatD [doc (showString "switch"), doc (showString "{"), prt 0 processswitchphrases, doc (showString "}")])
  prtList _ [] = concatD []
  prtList _ [x] = concatD [prt 0 x]
  prtList _ (x:xs) = concatD [prt 0 x, doc (showString ";"), prt 0 xs]

instance Print Language.AbsMPL.HCasePhrase where
  prt i e = case e of
    Language.AbsMPL.HCASE_PHRASE uident processcommandsblock -> prPrec i 0 (concatD [prt 0 uident, doc (showString "->"), prt 0 processcommandsblock])
  prtList _ [] = concatD []
  prtList _ [x] = concatD [prt 0 x]
  prtList _ (x:xs) = concatD [prt 0 x, doc (showString ";"), prt 0 xs]

instance Print [Language.AbsMPL.HCasePhrase] where
  prt = prtList

instance Print Language.AbsMPL.ForkPhrase where
  prt i e = case e of
    Language.AbsMPL.FORK_WITH_PHRASE pident pidents processcommandsblock -> prPrec i 0 (concatD [prt 0 pident, doc (showString "with"), prt 0 pidents, doc (showString "->"), prt 0 processcommandsblock])
    Language.AbsMPL.FORK_PHRASE pident processcommandsblock -> prPrec i 0 (concatD [prt 0 pident, doc (showString "->"), prt 0 processcommandsblock])
  prtList _ [] = concatD []
  prtList _ [x] = concatD [prt 0 x]
  prtList _ (x:xs) = concatD [prt 0 x, doc (showString ";"), prt 0 xs]

instance Print [Language.AbsMPL.ForkPhrase] where
  prt = prtList

instance Print Language.AbsMPL.RacePhrase where
  prt i e = case e of
    Language.AbsMPL.RACE_PHRASE pident processcommandsblock -> prPrec i 0 (concatD [prt 0 pident, doc (showString "->"), prt 0 processcommandsblock])
  prtList _ [] = concatD []
  prtList _ [x] = concatD [prt 0 x]
  prtList _ (x:xs) = concatD [prt 0 x, doc (showString ";"), prt 0 xs]

instance Print [Language.AbsMPL.RacePhrase] where
  prt = prtList

instance Print Language.AbsMPL.PlugPhrase where
  prt i e = case e of
    Language.AbsMPL.PLUG_PHRASE processcommandsblock -> prPrec i 0 (concatD [prt 0 processcommandsblock])
  prtList _ [] = concatD []
  prtList _ [x] = concatD [prt 0 x]
  prtList _ (x:xs) = concatD [prt 0 x, doc (showString ";"), prt 0 xs]

instance Print [Language.AbsMPL.PlugPhrase] where
  prt = prtList

instance Print Language.AbsMPL.ProcessCasePhrase where
  prt i e = case e of
    Language.AbsMPL.PROCESS_CASE_PHRASE patterns processcommandsblock -> prPrec i 0 (concatD [prt 0 patterns, doc (showString "->"), prt 0 processcommandsblock])
  prtList _ [] = concatD []
  prtList _ [x] = concatD [prt 0 x]
  prtList _ (x:xs) = concatD [prt 0 x, doc (showString ";"), prt 0 xs]

instance Print [Language.AbsMPL.ProcessCasePhrase] where
  prt = prtList

instance Print Language.AbsMPL.ProcessSwitchPhrase where
  prt i e = case e of
    Language.AbsMPL.PROCESS_SWITCH_PHRASE expr processcommandsblock -> prPrec i 0 (concatD [prt 0 expr, doc (showString "->"), prt 0 processcommandsblock])
  prtList _ [] = concatD []
  prtList _ [x] = concatD [prt 0 x]
  prtList _ (x:xs) = concatD [prt 0 x, doc (showString ";"), prt 0 xs]

instance Print [Language.AbsMPL.ProcessSwitchPhrase] where
  prt = prtList

