{-# LANGUAGE CPP #-}
#if __GLASGOW_HASKELL__ <= 708
{-# LANGUAGE OverlappingInstances #-}
#endif
{-# LANGUAGE FlexibleInstances #-}
{-# OPTIONS_GHC -fno-warn-incomplete-patterns #-}

-- | Pretty-printer for Language.
--   Generated by the BNF converter.

module Language.PrintMPL where

import qualified Language.AbsMPL
import Data.Char

-- | The top-level printing method.

printTree :: Print a => a -> String
printTree = render . prt 0

type Doc = [ShowS] -> [ShowS]

doc :: ShowS -> Doc
doc = (:)

render :: Doc -> String
render d = rend 0 (map ($ "") $ d []) "" where
  rend i ss = case ss of
    "["      :ts -> showChar '[' . rend i ts
    "("      :ts -> showChar '(' . rend i ts
    "{"      :ts -> showChar '{' . new (i+1) . rend (i+1) ts
    "}" : ";":ts -> new (i-1) . space "}" . showChar ';' . new (i-1) . rend (i-1) ts
    "}"      :ts -> new (i-1) . showChar '}' . new (i-1) . rend (i-1) ts
    [";"]        -> showChar ';'
    ";"      :ts -> showChar ';' . new i . rend i ts
    t  : ts@(p:_) | closingOrPunctuation p -> showString t . rend i ts
    t        :ts -> space t . rend i ts
    _            -> id
  new i     = showChar '\n' . replicateS (2*i) (showChar ' ') . dropWhile isSpace
  space t s =
    case (all isSpace t', null spc, null rest) of
      (True , _   , True ) -> []              -- remove trailing space
      (False, _   , True ) -> t'              -- remove trailing space
      (False, True, False) -> t' ++ ' ' : s   -- add space if none
      _                    -> t' ++ s
    where
      t'          = showString t []
      (spc, rest) = span isSpace s

  closingOrPunctuation :: String -> Bool
  closingOrPunctuation [c] = c `elem` closerOrPunct
  closingOrPunctuation _   = False

  closerOrPunct :: String
  closerOrPunct = ")],;"

parenth :: Doc -> Doc
parenth ss = doc (showChar '(') . ss . doc (showChar ')')

concatS :: [ShowS] -> ShowS
concatS = foldr (.) id

concatD :: [Doc] -> Doc
concatD = foldr (.) id

replicateS :: Int -> ShowS -> ShowS
replicateS n f = concatS (replicate n f)

-- | The printer class does the job.

class Print a where
  prt :: Int -> a -> Doc
  prtList :: Int -> [a] -> Doc
  prtList i = concatD . map (prt i)

instance {-# OVERLAPPABLE #-} Print a => Print [a] where
  prt = prtList

instance Print Char where
  prt _ s = doc (showChar '\'' . mkEsc '\'' s . showChar '\'')
  prtList _ s = doc (showChar '"' . concatS (map (mkEsc '"') s) . showChar '"')

mkEsc :: Char -> Char -> ShowS
mkEsc q s = case s of
  _ | s == q -> showChar '\\' . showChar s
  '\\'-> showString "\\\\"
  '\n' -> showString "\\n"
  '\t' -> showString "\\t"
  _ -> showChar s

prPrec :: Int -> Int -> Doc -> Doc
prPrec i j = if j < i then parenth else id

instance Print Integer where
  prt _ x = doc (shows x)

instance Print Double where
  prt _ x = doc (shows x)

instance Print Language.AbsMPL.PInteger where
  prt _ (Language.AbsMPL.PInteger (_,i)) = doc $ showString $ i

instance Print Language.AbsMPL.PDouble where
  prt _ (Language.AbsMPL.PDouble (_,i)) = doc $ showString $ i

instance Print Language.AbsMPL.PChar where
  prt _ (Language.AbsMPL.PChar (_,i)) = doc $ showString $ i

instance Print Language.AbsMPL.PString where
  prt _ (Language.AbsMPL.PString (_,i)) = doc $ showString $ i

instance Print Language.AbsMPL.Par where
  prt _ (Language.AbsMPL.Par (_,i)) = doc $ showString $ i

instance Print Language.AbsMPL.Tensor where
  prt _ (Language.AbsMPL.Tensor (_,i)) = doc $ showString $ i

instance Print Language.AbsMPL.LBracket where
  prt _ (Language.AbsMPL.LBracket (_,i)) = doc $ showString $ i

instance Print Language.AbsMPL.RBracket where
  prt _ (Language.AbsMPL.RBracket (_,i)) = doc $ showString $ i

instance Print Language.AbsMPL.LSquareBracket where
  prt _ (Language.AbsMPL.LSquareBracket (_,i)) = doc $ showString $ i

instance Print Language.AbsMPL.RSquareBracket where
  prt _ (Language.AbsMPL.RSquareBracket (_,i)) = doc $ showString $ i

instance Print Language.AbsMPL.NullPattern where
  prt _ (Language.AbsMPL.NullPattern (_,i)) = doc $ showString $ i

instance Print Language.AbsMPL.Colon where
  prt _ (Language.AbsMPL.Colon (_,i)) = doc $ showString $ i

instance Print Language.AbsMPL.Infixl1op where
  prt _ (Language.AbsMPL.Infixl1op (_,i)) = doc $ showString $ i

instance Print Language.AbsMPL.Infixl2op where
  prt _ (Language.AbsMPL.Infixl2op (_,i)) = doc $ showString $ i

instance Print Language.AbsMPL.Infixl3op where
  prt _ (Language.AbsMPL.Infixl3op (_,i)) = doc $ showString $ i

instance Print Language.AbsMPL.Infixl4op where
  prt _ (Language.AbsMPL.Infixl4op (_,i)) = doc $ showString $ i

instance Print Language.AbsMPL.Infixl5op where
  prt _ (Language.AbsMPL.Infixl5op (_,i)) = doc $ showString $ i

instance Print Language.AbsMPL.Infixl6op where
  prt _ (Language.AbsMPL.Infixl6op (_,i)) = doc $ showString $ i

instance Print Language.AbsMPL.Infixr7op where
  prt _ (Language.AbsMPL.Infixr7op (_,i)) = doc $ showString $ i

instance Print Language.AbsMPL.Infixl8op where
  prt _ (Language.AbsMPL.Infixl8op (_,i)) = doc $ showString $ i

instance Print Language.AbsMPL.Close where
  prt _ (Language.AbsMPL.Close (_,i)) = doc $ showString $ i

instance Print Language.AbsMPL.Halt where
  prt _ (Language.AbsMPL.Halt (_,i)) = doc $ showString $ i

instance Print Language.AbsMPL.Get where
  prt _ (Language.AbsMPL.Get (_,i)) = doc $ showString $ i

instance Print Language.AbsMPL.Put where
  prt _ (Language.AbsMPL.Put (_,i)) = doc $ showString $ i

instance Print Language.AbsMPL.HCase where
  prt _ (Language.AbsMPL.HCase (_,i)) = doc $ showString $ i

instance Print Language.AbsMPL.HPut where
  prt _ (Language.AbsMPL.HPut (_,i)) = doc $ showString $ i

instance Print Language.AbsMPL.Split where
  prt _ (Language.AbsMPL.Split (_,i)) = doc $ showString $ i

instance Print Language.AbsMPL.Fork where
  prt _ (Language.AbsMPL.Fork (_,i)) = doc $ showString $ i

instance Print Language.AbsMPL.ChId where
  prt _ (Language.AbsMPL.ChId (_,i)) = doc $ showString $ i

instance Print Language.AbsMPL.Case where
  prt _ (Language.AbsMPL.Case (_,i)) = doc $ showString $ i

instance Print Language.AbsMPL.UIdent where
  prt _ (Language.AbsMPL.UIdent (_,i)) = doc $ showString $ i

instance Print Language.AbsMPL.PIdent where
  prt _ (Language.AbsMPL.PIdent (_,i)) = doc $ showString $ i
  prtList _ [] = concatD []
  prtList _ [x] = concatD [prt 0 x]
  prtList _ (x:xs) = concatD [prt 0 x, doc (showString ","), prt 0 xs]

instance Print Language.AbsMPL.UPIdent where
  prt _ (Language.AbsMPL.UPIdent (_,i)) = doc $ showString $ i

instance Print [Language.AbsMPL.PIdent] where
  prt = prtList

instance Print Language.AbsMPL.MplProg where
  prt i e = case e of
    Language.AbsMPL.MPL_PROG mplstmts -> prPrec i 0 (concatD [prt 0 mplstmts])

instance Print Language.AbsMPL.MplStmt where
  prt i e = case e of
    Language.AbsMPL.MPL_DEFN_STMS_WHERE mpldefns mplwheres -> prPrec i 0 (concatD [doc (showString "defn"), doc (showString "{"), prt 0 mpldefns, doc (showString "}"), doc (showString "where"), doc (showString "{"), prt 0 mplwheres, doc (showString "}")])
    Language.AbsMPL.MPL_DEFN_STMS mpldefns -> prPrec i 0 (concatD [doc (showString "defn"), doc (showString "{"), prt 0 mpldefns, doc (showString "}")])
    Language.AbsMPL.MPL_STMT mpldefn -> prPrec i 0 (concatD [prt 0 mpldefn])
  prtList _ [] = concatD []
  prtList _ (x:xs) = concatD [prt 0 x, prt 0 xs]

instance Print [Language.AbsMPL.MplDefn] where
  prt = prtList

instance Print [Language.AbsMPL.MplStmt] where
  prt = prtList

instance Print Language.AbsMPL.MplWhere where
  prt i e = case e of
    Language.AbsMPL.MPL_WHERE mplstmt -> prPrec i 0 (concatD [prt 0 mplstmt])
  prtList _ [] = concatD []
  prtList _ [x] = concatD [prt 0 x]
  prtList _ (x:xs) = concatD [prt 0 x, doc (showString ";"), prt 0 xs]

instance Print [Language.AbsMPL.MplWhere] where
  prt = prtList

instance Print Language.AbsMPL.MplDefn where
  prt i e = case e of
    Language.AbsMPL.MPL_SEQUENTIAL_TYPE_DEFN sequentialtypedefn -> prPrec i 0 (concatD [prt 0 sequentialtypedefn])
    Language.AbsMPL.MPL_CONCURRENT_TYPE_DEFN concurrenttypedefn -> prPrec i 0 (concatD [prt 0 concurrenttypedefn])
    Language.AbsMPL.MPL_FUNCTION_DEFN functiondefn -> prPrec i 0 (concatD [prt 0 functiondefn])
    Language.AbsMPL.MPL_PROCESS_DEFN processdefn -> prPrec i 0 (concatD [prt 0 processdefn])
    Language.AbsMPL.MPL_DEFNTEST -> prPrec i 0 (concatD [doc (showString "potato")])
  prtList _ [x] = concatD [prt 0 x]
  prtList _ (x:xs) = concatD [prt 0 x, doc (showString ";"), prt 0 xs]

instance Print Language.AbsMPL.MplType where
  prt i e = case e of
    Language.AbsMPL.MPL_TYPE mpltype -> prPrec i 0 (concatD [prt 0 mpltype])
    Language.AbsMPL.PAR_TYPE mpltype1 par mpltype2 -> prPrec i 0 (concatD [prt 1 mpltype1, prt 0 par, prt 1 mpltype2])
    Language.AbsMPL.TENSOR_TYPE mpltype1 tensor mpltype2 -> prPrec i 1 (concatD [prt 2 mpltype1, prt 0 tensor, prt 2 mpltype2])
    Language.AbsMPL.MPL_UIDENT_ARGS_TYPE uident lbracket mpltypes rbracket -> prPrec i 2 (concatD [prt 0 uident, prt 0 lbracket, prt 0 mpltypes, prt 0 rbracket])
    Language.AbsMPL.MPL_UIDENT_SEQ_CONC_ARGS_TYPE uident lbracket mpltypes1 mpltypes2 rbracket -> prPrec i 2 (concatD [prt 0 uident, prt 0 lbracket, prt 0 mpltypes1, doc (showString "|"), prt 0 mpltypes2, prt 0 rbracket])
    Language.AbsMPL.MPL_UIDENT_NO_ARGS_TYPE uident -> prPrec i 2 (concatD [prt 0 uident])
    Language.AbsMPL.MPL_UNIT_TYPE lbracket rbracket -> prPrec i 2 (concatD [prt 0 lbracket, prt 0 rbracket])
    Language.AbsMPL.MPL_BRACKETED_TYPE lbracket mpltype rbracket -> prPrec i 2 (concatD [prt 0 lbracket, prt 0 mpltype, prt 0 rbracket])
    Language.AbsMPL.MPL_LIST_TYPE lsquarebracket mpltype rsquarebracket -> prPrec i 2 (concatD [prt 0 lsquarebracket, prt 0 mpltype, prt 0 rsquarebracket])
    Language.AbsMPL.MPL_TUPLE_TYPE lbracket mpltype tuplelisttypes rbracket -> prPrec i 2 (concatD [prt 0 lbracket, prt 0 mpltype, doc (showString ","), prt 0 tuplelisttypes, prt 0 rbracket])
    Language.AbsMPL.MPL_SEQ_ARROW_TYPE forallvarlists mpltypes mpltype -> prPrec i 2 (concatD [doc (showString "forall"), prt 0 forallvarlists, doc (showString "."), prt 0 mpltypes, doc (showString "->"), prt 0 mpltype])
    Language.AbsMPL.MPL_CONC_ARROW_TYPE forallvarlists mpltypes1 mpltypes2 mpltypes3 -> prPrec i 2 (concatD [doc (showString "forall"), prt 0 forallvarlists, doc (showString "."), prt 0 mpltypes1, doc (showString "|"), prt 0 mpltypes2, doc (showString "=>"), prt 0 mpltypes3])
  prtList _ [] = concatD []
  prtList _ [x] = concatD [prt 0 x]
  prtList _ (x:xs) = concatD [prt 0 x, doc (showString ","), prt 0 xs]

instance Print Language.AbsMPL.TupleListType where
  prt i e = case e of
    Language.AbsMPL.TUPLE_LIST_TYPE mpltype -> prPrec i 0 (concatD [prt 0 mpltype])
  prtList _ [x] = concatD [prt 0 x]
  prtList _ (x:xs) = concatD [prt 0 x, doc (showString ","), prt 0 xs]

instance Print Language.AbsMPL.ForallVarList where
  prt i e = case e of
    Language.AbsMPL.MPL_SEQ_FUN_TYPE_FORALL_LIST uident -> prPrec i 0 (concatD [prt 0 uident])
  prtList _ [] = concatD []
  prtList _ (x:xs) = concatD [prt 0 x, doc (showString " "), prt 0 xs]

instance Print [Language.AbsMPL.ForallVarList] where
  prt = prtList

instance Print [Language.AbsMPL.TupleListType] where
  prt = prtList

instance Print [Language.AbsMPL.MplType] where
  prt = prtList

instance Print Language.AbsMPL.SequentialTypeDefn where
  prt i e = case e of
    Language.AbsMPL.DATA_DEFN seqtypeclausedefns -> prPrec i 0 (concatD [doc (showString "data"), prt 0 seqtypeclausedefns])
    Language.AbsMPL.CODATA_DEFN seqtypeclausedefns -> prPrec i 0 (concatD [doc (showString "codata"), prt 0 seqtypeclausedefns])

instance Print Language.AbsMPL.SeqTypeClauseDefn where
  prt i e = case e of
    Language.AbsMPL.SEQ_TYPE_CLAUSE mpltype1 mpltype2 seqtypephrasedefns -> prPrec i 0 (concatD [prt 0 mpltype1, doc (showString "->"), prt 0 mpltype2, doc (showString "="), doc (showString "{"), prt 0 seqtypephrasedefns, doc (showString "}")])
  prtList _ [x] = concatD [prt 0 x]
  prtList _ (x:xs) = concatD [prt 0 x, doc (showString "and"), prt 0 xs]

instance Print Language.AbsMPL.SeqTypePhraseDefn where
  prt i e = case e of
    Language.AbsMPL.SEQ_TYPE_PHRASE typehandlenames mpltypes mpltype -> prPrec i 0 (concatD [prt 0 typehandlenames, doc (showString "::"), prt 0 mpltypes, doc (showString "->"), prt 0 mpltype])
  prtList _ [] = concatD []
  prtList _ [x] = concatD [prt 0 x]
  prtList _ (x:xs) = concatD [prt 0 x, doc (showString ";"), prt 0 xs]

instance Print [Language.AbsMPL.SeqTypeClauseDefn] where
  prt = prtList

instance Print [Language.AbsMPL.SeqTypePhraseDefn] where
  prt = prtList

instance Print Language.AbsMPL.ConcurrentTypeDefn where
  prt i e = case e of
    Language.AbsMPL.PROTOCOL_DEFN concurrenttypeclausedefns -> prPrec i 0 (concatD [doc (showString "protocol"), prt 0 concurrenttypeclausedefns])
    Language.AbsMPL.COPROTOCOL_DEFN concurrenttypeclausedefns -> prPrec i 0 (concatD [doc (showString "coprotocol"), prt 0 concurrenttypeclausedefns])

instance Print Language.AbsMPL.ConcurrentTypeClauseDefn where
  prt i e = case e of
    Language.AbsMPL.CONCURRENT_TYPE_CLAUSE mpltype1 mpltype2 concurrenttypephrasedefns -> prPrec i 0 (concatD [prt 0 mpltype1, doc (showString "=>"), prt 0 mpltype2, doc (showString "="), doc (showString "{"), prt 0 concurrenttypephrasedefns, doc (showString "}")])
  prtList _ [x] = concatD [prt 0 x]
  prtList _ (x:xs) = concatD [prt 0 x, doc (showString "and"), prt 0 xs]

instance Print Language.AbsMPL.ConcurrentTypePhraseDefn where
  prt i e = case e of
    Language.AbsMPL.CONCURRENT_TYPE_PHRASE typehandlenames mpltype1 mpltype2 -> prPrec i 0 (concatD [prt 0 typehandlenames, doc (showString "::"), prt 0 mpltype1, doc (showString "=>"), prt 0 mpltype2])
  prtList _ [] = concatD []
  prtList _ [x] = concatD [prt 0 x]
  prtList _ (x:xs) = concatD [prt 0 x, doc (showString ";"), prt 0 xs]

instance Print [Language.AbsMPL.ConcurrentTypeClauseDefn] where
  prt = prtList

instance Print [Language.AbsMPL.ConcurrentTypePhraseDefn] where
  prt = prtList

instance Print Language.AbsMPL.TypeHandleName where
  prt i e = case e of
    Language.AbsMPL.TYPE_HANDLE_NAME uident -> prPrec i 0 (concatD [prt 0 uident])
  prtList _ [x] = concatD [prt 0 x]
  prtList _ (x:xs) = concatD [prt 0 x, doc (showString ","), prt 0 xs]

instance Print [Language.AbsMPL.TypeHandleName] where
  prt = prtList

instance Print Language.AbsMPL.Expr where
  prt i e = case e of
    Language.AbsMPL.EXPR expr -> prPrec i 0 (concatD [prt 0 expr])
    Language.AbsMPL.TYPED_EXPR expr mpltype -> prPrec i 0 (concatD [prt 0 expr, doc (showString "::"), prt 0 mpltype])
    Language.AbsMPL.IF_EXPR expr1 expr2 expr3 -> prPrec i 0 (concatD [doc (showString "if"), prt 0 expr1, doc (showString "then"), prt 0 expr2, doc (showString "else"), prt 0 expr3])
    Language.AbsMPL.LET_EXPR letexprphrases expr -> prPrec i 0 (concatD [doc (showString "let"), doc (showString "{"), prt 0 letexprphrases, doc (showString "}"), doc (showString "in"), prt 0 expr])
    Language.AbsMPL.INFIXR0_EXPR expr1 colon expr2 -> prPrec i 0 (concatD [prt 1 expr1, prt 0 colon, prt 0 expr2])
    Language.AbsMPL.INFIXL1_EXPR expr1 infixlop expr2 -> prPrec i 1 (concatD [prt 1 expr1, prt 0 infixlop, prt 2 expr2])
    Language.AbsMPL.INFIXL2_EXPR expr1 infixlop expr2 -> prPrec i 2 (concatD [prt 2 expr1, prt 0 infixlop, prt 3 expr2])
    Language.AbsMPL.INFIXL3_EXPR expr1 infixlop expr2 -> prPrec i 3 (concatD [prt 3 expr1, prt 0 infixlop, prt 4 expr2])
    Language.AbsMPL.INFIXL4_EXPR expr1 infixlop expr2 -> prPrec i 4 (concatD [prt 4 expr1, prt 0 infixlop, prt 5 expr2])
    Language.AbsMPL.INFIXL5_EXPR expr1 infixlop expr2 -> prPrec i 5 (concatD [prt 5 expr1, prt 0 infixlop, prt 6 expr2])
    Language.AbsMPL.INFIXL6_EXPR expr1 infixlop expr2 -> prPrec i 6 (concatD [prt 6 expr1, prt 0 infixlop, prt 7 expr2])
    Language.AbsMPL.INFIXR7_EXPR expr1 infixrop expr2 -> prPrec i 7 (concatD [prt 8 expr1, prt 0 infixrop, prt 7 expr2])
    Language.AbsMPL.INFIXL8_EXPR expr1 infixlop expr2 -> prPrec i 8 (concatD [prt 8 expr1, prt 0 infixlop, prt 10 expr2])
    Language.AbsMPL.LIST_EXPR lsquarebracket exprs rsquarebracket -> prPrec i 10 (concatD [prt 0 lsquarebracket, prt 0 exprs, prt 0 rsquarebracket])
    Language.AbsMPL.VAR_EXPR pident -> prPrec i 10 (concatD [prt 0 pident])
    Language.AbsMPL.INT_EXPR pinteger -> prPrec i 10 (concatD [prt 0 pinteger])
    Language.AbsMPL.STRING_EXPR pstring -> prPrec i 10 (concatD [prt 0 pstring])
    Language.AbsMPL.CHAR_EXPR pchar -> prPrec i 10 (concatD [prt 0 pchar])
    Language.AbsMPL.DOUBLE_EXPR pdouble -> prPrec i 10 (concatD [prt 0 pdouble])
    Language.AbsMPL.UNIT_EXPR lbracket rbracket -> prPrec i 10 (concatD [prt 0 lbracket, prt 0 rbracket])
    Language.AbsMPL.FOLD_EXPR expr foldexprphrases -> prPrec i 10 (concatD [doc (showString "fold"), prt 0 expr, doc (showString "of"), doc (showString "{"), prt 0 foldexprphrases, doc (showString "}")])
    Language.AbsMPL.UNFOLD_EXPR expr unfoldexprphrases -> prPrec i 10 (concatD [doc (showString "unfold"), prt 0 expr, doc (showString "of"), doc (showString "{"), prt 0 unfoldexprphrases, doc (showString "}")])
    Language.AbsMPL.CASE_EXPR case_ expr pattexprphrases -> prPrec i 10 (concatD [prt 0 case_, prt 0 expr, doc (showString "of"), doc (showString "{"), prt 0 pattexprphrases, doc (showString "}")])
    Language.AbsMPL.SWITCH_EXP switchexprphrases -> prPrec i 10 (concatD [doc (showString "switch"), doc (showString "{"), prt 0 switchexprphrases, doc (showString "}")])
    Language.AbsMPL.DESTRUCTOR_CONSTRUCTOR_ARGS_EXPR uident lbracket exprs rbracket -> prPrec i 10 (concatD [prt 0 uident, prt 0 lbracket, prt 0 exprs, prt 0 rbracket])
    Language.AbsMPL.DESTRUCTOR_CONSTRUCTOR_NO_ARGS_EXPR uident -> prPrec i 10 (concatD [prt 0 uident])
    Language.AbsMPL.TUPLE_EXPR lbracket expr tupleexprlists rbracket -> prPrec i 10 (concatD [prt 0 lbracket, prt 0 expr, doc (showString ","), prt 0 tupleexprlists, prt 0 rbracket])
    Language.AbsMPL.FUN_EXPR pident lbracket exprs rbracket -> prPrec i 10 (concatD [prt 0 pident, prt 0 lbracket, prt 0 exprs, prt 0 rbracket])
    Language.AbsMPL.RECORD_EXPR lbracket recordexprphrases rbracket -> prPrec i 10 (concatD [prt 0 lbracket, prt 0 recordexprphrases, prt 0 rbracket])
    Language.AbsMPL.BRACKETED_EXPR lbracket expr rbracket -> prPrec i 10 (concatD [prt 0 lbracket, prt 0 expr, prt 0 rbracket])
  prtList _ [] = concatD []
  prtList _ [x] = concatD [prt 0 x]
  prtList _ (x:xs) = concatD [prt 0 x, doc (showString ","), prt 0 xs]

instance Print Language.AbsMPL.UnfoldExprPhrase where
  prt i e = case e of
    Language.AbsMPL.UNFOLD_EXPR_PHRASE pattern_ foldexprphrases -> prPrec i 0 (concatD [prt 0 pattern_, doc (showString "of"), doc (showString "{"), prt 0 foldexprphrases, doc (showString "}")])
  prtList _ [x] = concatD [prt 0 x]
  prtList _ (x:xs) = concatD [prt 0 x, doc (showString ";"), prt 0 xs]

instance Print [Language.AbsMPL.UnfoldExprPhrase] where
  prt = prtList

instance Print Language.AbsMPL.FoldExprPhrase where
  prt i e = case e of
    Language.AbsMPL.FOLD_EXPR_PHRASE uident colon patterns expr -> prPrec i 0 (concatD [prt 0 uident, prt 0 colon, prt 0 patterns, doc (showString "->"), prt 0 expr])
  prtList _ [x] = concatD [prt 0 x]
  prtList _ (x:xs) = concatD [prt 0 x, doc (showString ";"), prt 0 xs]

instance Print [Language.AbsMPL.FoldExprPhrase] where
  prt = prtList

instance Print Language.AbsMPL.LetExprPhrase where
  prt i e = case e of
    Language.AbsMPL.LET_EXPR_PHRASE mplstmt -> prPrec i 0 (concatD [prt 0 mplstmt])
  prtList _ [x] = concatD [prt 0 x]
  prtList _ (x:xs) = concatD [prt 0 x, doc (showString ";"), prt 0 xs]

instance Print [Language.AbsMPL.LetExprPhrase] where
  prt = prtList

instance Print Language.AbsMPL.TupleExprList where
  prt i e = case e of
    Language.AbsMPL.TUPLE_EXPR_LIST expr -> prPrec i 0 (concatD [prt 0 expr])
  prtList _ [x] = concatD [prt 0 x]
  prtList _ (x:xs) = concatD [prt 0 x, doc (showString ","), prt 0 xs]

instance Print [Language.AbsMPL.TupleExprList] where
  prt = prtList

instance Print Language.AbsMPL.RecordExprPhrase where
  prt i e = case e of
    Language.AbsMPL.RECORD_EXPR_PHRASE uident expr -> prPrec i 0 (concatD [prt 0 uident, doc (showString ":="), prt 0 expr])
    Language.AbsMPL.RECORD_EXPR_HIGHER_ORDER_PHRASE uident pattexprphrase -> prPrec i 0 (concatD [prt 0 uident, doc (showString ":="), prt 0 pattexprphrase])
  prtList _ [x] = concatD [prt 0 x]
  prtList _ (x:xs) = concatD [prt 0 x, doc (showString ","), prt 0 xs]

instance Print [Language.AbsMPL.RecordExprPhrase] where
  prt = prtList

instance Print Language.AbsMPL.SwitchExprPhrase where
  prt i e = case e of
    Language.AbsMPL.SWITCH_EXPR_PHRASE expr1 expr2 -> prPrec i 0 (concatD [prt 0 expr1, doc (showString "->"), prt 0 expr2])
  prtList _ [x] = concatD [prt 0 x]
  prtList _ (x:xs) = concatD [prt 0 x, doc (showString ";"), prt 0 xs]

instance Print [Language.AbsMPL.SwitchExprPhrase] where
  prt = prtList

instance Print [Language.AbsMPL.Expr] where
  prt = prtList

instance Print Language.AbsMPL.PattExprPhrase where
  prt i e = case e of
    Language.AbsMPL.PATTERN_TO_EXPR patterns expr -> prPrec i 0 (concatD [prt 0 patterns, doc (showString "->"), prt 0 expr])
  prtList _ [x] = concatD [prt 0 x]
  prtList _ (x:xs) = concatD [prt 0 x, doc (showString ";"), prt 0 xs]

instance Print Language.AbsMPL.Pattern where
  prt i e = case e of
    Language.AbsMPL.PATTERN pattern_ -> prPrec i 0 (concatD [prt 0 pattern_])
    Language.AbsMPL.TYPED_PATTERN pattern_ mpltype -> prPrec i 0 (concatD [prt 0 pattern_, doc (showString "::"), prt 0 mpltype])
    Language.AbsMPL.LIST_COLON_PATTERN pattern_1 colon pattern_2 -> prPrec i 0 (concatD [prt 1 pattern_1, prt 0 colon, prt 0 pattern_2])
    Language.AbsMPL.CONSTRUCTOR_PATTERN_ARGS uident lbracket patterns rbracket -> prPrec i 1 (concatD [prt 0 uident, prt 0 lbracket, prt 0 patterns, prt 0 rbracket])
    Language.AbsMPL.CONSTRUCTOR_PATTERN_NO_ARGS uident -> prPrec i 1 (concatD [prt 0 uident])
    Language.AbsMPL.UNIT_PATTERN lbracket rbracket -> prPrec i 1 (concatD [prt 0 lbracket, prt 0 rbracket])
    Language.AbsMPL.RECORD_PATTERN lbracket destructorpatternphrases rbracket -> prPrec i 1 (concatD [prt 0 lbracket, prt 0 destructorpatternphrases, prt 0 rbracket])
    Language.AbsMPL.LIST_PATTERN lsquarebracket patterns rsquarebracket -> prPrec i 1 (concatD [prt 0 lsquarebracket, prt 0 patterns, prt 0 rsquarebracket])
    Language.AbsMPL.TUPLE_PATTERN lbracket pattern_ tuplelistpatterns rbracket -> prPrec i 1 (concatD [prt 0 lbracket, prt 0 pattern_, doc (showString ","), prt 0 tuplelistpatterns, prt 0 rbracket])
    Language.AbsMPL.VAR_PATTERN pident -> prPrec i 1 (concatD [prt 0 pident])
    Language.AbsMPL.STR_PATTERN pstring -> prPrec i 1 (concatD [prt 0 pstring])
    Language.AbsMPL.CHAR_PATTERN pchar -> prPrec i 1 (concatD [prt 0 pchar])
    Language.AbsMPL.INT_PATTERN pinteger -> prPrec i 1 (concatD [prt 0 pinteger])
    Language.AbsMPL.NULL_PATTERN nullpattern -> prPrec i 1 (concatD [prt 0 nullpattern])
    Language.AbsMPL.BRACKETED_PATTERN lbracket pattern_ rbracket -> prPrec i 1 (concatD [prt 0 lbracket, prt 0 pattern_, prt 0 rbracket])
  prtList _ [] = concatD []
  prtList _ [x] = concatD [prt 0 x]
  prtList _ (x:xs) = concatD [prt 0 x, doc (showString ","), prt 0 xs]

instance Print [Language.AbsMPL.Pattern] where
  prt = prtList

instance Print Language.AbsMPL.TupleListPattern where
  prt i e = case e of
    Language.AbsMPL.TUPLE_LIST_PATTERN pattern_ -> prPrec i 0 (concatD [prt 0 pattern_])
  prtList _ [x] = concatD [prt 0 x]
  prtList _ (x:xs) = concatD [prt 0 x, doc (showString ","), prt 0 xs]

instance Print [Language.AbsMPL.TupleListPattern] where
  prt = prtList

instance Print Language.AbsMPL.DestructorPatternPhrase where
  prt i e = case e of
    Language.AbsMPL.DESTRUCTOR_PATTERN_PHRASE uident pattern_ -> prPrec i 0 (concatD [prt 0 uident, doc (showString ":="), prt 0 pattern_])
  prtList _ [x] = concatD [prt 0 x]
  prtList _ (x:xs) = concatD [prt 0 x, doc (showString ","), prt 0 xs]

instance Print [Language.AbsMPL.DestructorPatternPhrase] where
  prt = prtList

instance Print Language.AbsMPL.FunctionDefn where
  prt i e = case e of
    Language.AbsMPL.INTERNAL_TYPED_FUNCTION_DEFN pident mpltype pattexprphrases -> prPrec i 0 (concatD [doc (showString "fun"), prt 0 pident, doc (showString "::"), prt 0 mpltype, doc (showString "="), doc (showString "{"), prt 0 pattexprphrases, doc (showString "}")])
    Language.AbsMPL.TYPED_FUNCTION_DEFN pident mpltypes mpltype pattexprphrases -> prPrec i 0 (concatD [doc (showString "fun"), prt 0 pident, doc (showString "::"), prt 0 mpltypes, doc (showString "->"), prt 0 mpltype, doc (showString "="), doc (showString "{"), prt 0 pattexprphrases, doc (showString "}")])
    Language.AbsMPL.FUNCTION_DEFN pident pattexprphrases -> prPrec i 0 (concatD [doc (showString "fun"), prt 0 pident, doc (showString "="), doc (showString "{"), prt 0 pattexprphrases, doc (showString "}")])

instance Print [Language.AbsMPL.PattExprPhrase] where
  prt = prtList

instance Print Language.AbsMPL.ProcessDefn where
  prt i e = case e of
    Language.AbsMPL.TYPED_PROCESS_DEFN pident mpltypes1 mpltypes2 mpltypes3 processphrases -> prPrec i 0 (concatD [doc (showString "proc"), prt 0 pident, doc (showString "::"), prt 0 mpltypes1, doc (showString "|"), prt 0 mpltypes2, doc (showString "=>"), prt 0 mpltypes3, doc (showString "="), doc (showString "{"), prt 0 processphrases, doc (showString "}")])
    Language.AbsMPL.INTERNAL_TYPED_PROCESS_DEFN pident mpltype processphrases -> prPrec i 0 (concatD [doc (showString "proc"), prt 0 pident, doc (showString "::"), prt 0 mpltype, doc (showString "="), doc (showString "{"), prt 0 processphrases, doc (showString "}")])
    Language.AbsMPL.PROCESS_DEFN pident processphrases -> prPrec i 0 (concatD [doc (showString "proc"), prt 0 pident, doc (showString "="), doc (showString "{"), prt 0 processphrases, doc (showString "}")])

instance Print Language.AbsMPL.ProcessPhrase where
  prt i e = case e of
    Language.AbsMPL.PROCESS_PHRASE patterns pidents1 pidents2 processcommandsblock -> prPrec i 0 (concatD [prt 0 patterns, doc (showString "|"), prt 0 pidents1, doc (showString "=>"), prt 0 pidents2, doc (showString "->"), prt 0 processcommandsblock])
  prtList _ [x] = concatD [prt 0 x]
  prtList _ (x:xs) = concatD [prt 0 x, doc (showString ";"), prt 0 xs]

instance Print [Language.AbsMPL.ProcessPhrase] where
  prt = prtList

instance Print Language.AbsMPL.ProcessCommandsBlock where
  prt i e = case e of
    Language.AbsMPL.PROCESS_COMMANDS_DO_BLOCK processcommands -> prPrec i 0 (concatD [doc (showString "do"), doc (showString "{"), prt 0 processcommands, doc (showString "}")])
    Language.AbsMPL.PROCESS_COMMANDS_SINGLE_COMMAND_BLOCK processcommand -> prPrec i 0 (concatD [prt 0 processcommand])

instance Print [Language.AbsMPL.ProcessCommand] where
  prt = prtList

instance Print Language.AbsMPL.ProcessCommand where
  prt i e = case e of
    Language.AbsMPL.PROCESS_RUN pident lbracket exprs pidents1 pidents2 rbracket -> prPrec i 0 (concatD [prt 0 pident, prt 0 lbracket, prt 0 exprs, doc (showString "|"), prt 0 pidents1, doc (showString "=>"), prt 0 pidents2, prt 0 rbracket])
    Language.AbsMPL.PROCESS_CLOSE close pident -> prPrec i 0 (concatD [prt 0 close, prt 0 pident])
    Language.AbsMPL.PROCESS_HALT halt pident -> prPrec i 0 (concatD [prt 0 halt, prt 0 pident])
    Language.AbsMPL.PROCESS_GET get pattern_ pident -> prPrec i 0 (concatD [prt 0 get, prt 0 pattern_, doc (showString "on"), prt 0 pident])
    Language.AbsMPL.PROCESS_PUT put expr pident -> prPrec i 0 (concatD [prt 0 put, prt 0 expr, doc (showString "on"), prt 0 pident])
    Language.AbsMPL.PROCESS_HCASE hcase pident hcasephrases -> prPrec i 0 (concatD [prt 0 hcase, prt 0 pident, doc (showString "of"), doc (showString "{"), prt 0 hcasephrases, doc (showString "}")])
    Language.AbsMPL.PROCESS_HPUT hput uident pident -> prPrec i 0 (concatD [prt 0 hput, prt 0 uident, doc (showString "on"), prt 0 pident])
    Language.AbsMPL.PROCESS_SPLIT split pident splitchannels -> prPrec i 0 (concatD [prt 0 split, prt 0 pident, doc (showString "into"), prt 0 splitchannels])
    Language.AbsMPL.PROCESS_FORK fork pident forkphrases -> prPrec i 0 (concatD [prt 0 fork, prt 0 pident, doc (showString "as"), doc (showString "{"), prt 0 forkphrases, doc (showString "}")])
    Language.AbsMPL.PROCESS_ID pident1 chid pident2 -> prPrec i 0 (concatD [prt 0 pident1, prt 0 chid, prt 0 pident2])
    Language.AbsMPL.PROCESS_NEG pident1 chid pident2 -> prPrec i 0 (concatD [prt 0 pident1, prt 0 chid, doc (showString "neg"), prt 0 pident2])
    Language.AbsMPL.PROCESS_RACE racephrases -> prPrec i 0 (concatD [doc (showString "race"), doc (showString "{"), prt 0 racephrases, doc (showString "}")])
    Language.AbsMPL.PROCESS_PLUG plugphrases -> prPrec i 0 (concatD [doc (showString "plug"), doc (showString "{"), prt 0 plugphrases, doc (showString "}")])
    Language.AbsMPL.PROCESS_CASE case_ expr processcasephrases -> prPrec i 0 (concatD [prt 0 case_, prt 0 expr, doc (showString "of"), doc (showString "{"), prt 0 processcasephrases, doc (showString "}")])
    Language.AbsMPL.PROCESS_IF expr processcommandsblock1 processcommandsblock2 -> prPrec i 0 (concatD [doc (showString "if"), prt 0 expr, doc (showString "then"), prt 0 processcommandsblock1, doc (showString "else"), prt 0 processcommandsblock2])
    Language.AbsMPL.PROCESS_SWITCH processswitchphrases -> prPrec i 0 (concatD [doc (showString "switch"), doc (showString "{"), prt 0 processswitchphrases, doc (showString "}")])
  prtList _ [x] = concatD [prt 0 x]
  prtList _ (x:xs) = concatD [prt 0 x, doc (showString ";"), prt 0 xs]

instance Print Language.AbsMPL.HCasePhrase where
  prt i e = case e of
    Language.AbsMPL.HCASE_PHRASE uident processcommandsblock -> prPrec i 0 (concatD [prt 0 uident, doc (showString "->"), prt 0 processcommandsblock])
  prtList _ [] = concatD []
  prtList _ [x] = concatD [prt 0 x]
  prtList _ (x:xs) = concatD [prt 0 x, doc (showString ";"), prt 0 xs]

instance Print [Language.AbsMPL.HCasePhrase] where
  prt = prtList

instance Print Language.AbsMPL.SplitChannel where
  prt i e = case e of
    Language.AbsMPL.SPLIT_CHANNEL pident -> prPrec i 0 (concatD [prt 0 pident])
  prtList _ [x] = concatD [prt 0 x]
  prtList _ (x:xs) = concatD [prt 0 x, doc (showString ","), prt 0 xs]

instance Print [Language.AbsMPL.SplitChannel] where
  prt = prtList

instance Print Language.AbsMPL.ForkPhrase where
  prt i e = case e of
    Language.AbsMPL.FORK_PHRASE pident processcommandsblock -> prPrec i 0 (concatD [prt 0 pident, doc (showString "->"), prt 0 processcommandsblock])
    Language.AbsMPL.FORK_WITH_PHRASE pident forkchannels processcommandsblock -> prPrec i 0 (concatD [prt 0 pident, doc (showString "with"), prt 0 forkchannels, doc (showString "->"), prt 0 processcommandsblock])
  prtList _ [x] = concatD [prt 0 x]
  prtList _ (x:xs) = concatD [prt 0 x, doc (showString ";"), prt 0 xs]

instance Print [Language.AbsMPL.ForkPhrase] where
  prt = prtList

instance Print Language.AbsMPL.ForkChannel where
  prt i e = case e of
    Language.AbsMPL.FORK_CHANNEL pident -> prPrec i 0 (concatD [prt 0 pident])
  prtList _ [] = concatD []
  prtList _ [x] = concatD [prt 0 x]
  prtList _ (x:xs) = concatD [prt 0 x, doc (showString ";"), prt 0 xs]

instance Print [Language.AbsMPL.ForkChannel] where
  prt = prtList

instance Print Language.AbsMPL.RacePhrase where
  prt i e = case e of
    Language.AbsMPL.RACE_PHRASE pident processcommandsblock -> prPrec i 0 (concatD [prt 0 pident, doc (showString "->"), prt 0 processcommandsblock])
  prtList _ [] = concatD []
  prtList _ [x] = concatD [prt 0 x]
  prtList _ (x:xs) = concatD [prt 0 x, doc (showString ";"), prt 0 xs]

instance Print [Language.AbsMPL.RacePhrase] where
  prt = prtList

instance Print Language.AbsMPL.PlugPhrase where
  prt i e = case e of
    Language.AbsMPL.PLUG_PHRASE processcommandsblock -> prPrec i 0 (concatD [prt 0 processcommandsblock])
    Language.AbsMPL.PLUG_PHRASE_AS pidents1 pidents2 processcommandsblock -> prPrec i 0 (concatD [prt 0 pidents1, doc (showString "=>"), prt 0 pidents2, doc (showString "->"), prt 0 processcommandsblock])
  prtList _ [x] = concatD [prt 0 x]
  prtList _ (x:xs) = concatD [prt 0 x, doc (showString ";"), prt 0 xs]

instance Print [Language.AbsMPL.PlugPhrase] where
  prt = prtList

instance Print Language.AbsMPL.ProcessCasePhrase where
  prt i e = case e of
    Language.AbsMPL.PROCESS_CASE_PHRASE pattern_ processcommandsblock -> prPrec i 0 (concatD [prt 0 pattern_, doc (showString "->"), prt 0 processcommandsblock])
  prtList _ [x] = concatD [prt 0 x]
  prtList _ (x:xs) = concatD [prt 0 x, doc (showString ";"), prt 0 xs]

instance Print [Language.AbsMPL.ProcessCasePhrase] where
  prt = prtList

instance Print Language.AbsMPL.ProcessSwitchPhrase where
  prt i e = case e of
    Language.AbsMPL.PROCESS_SWITCH_PHRASE expr processcommandsblock -> prPrec i 0 (concatD [prt 0 expr, doc (showString "->"), prt 0 processcommandsblock])
  prtList _ [x] = concatD [prt 0 x]
  prtList _ (x:xs) = concatD [prt 0 x, doc (showString ";"), prt 0 xs]

instance Print [Language.AbsMPL.ProcessSwitchPhrase] where
  prt = prtList

