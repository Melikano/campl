-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module Language.ParMPL
  ( happyError
  , myLexer
  , pMplProg
  ) where
import qualified Language.AbsMPL
import Language.LexMPL
}

%name pMplProg MplProg
-- no lexer declaration
%monad { Either String } { (>>=) } { return }
%tokentype {Token}
%token
  ',' { PT _ (TS _ 1) }
  '->' { PT _ (TS _ 2) }
  '::' { PT _ (TS _ 3) }
  ':=' { PT _ (TS _ 4) }
  ';' { PT _ (TS _ 5) }
  '=' { PT _ (TS _ 6) }
  '=>' { PT _ (TS _ 7) }
  'and' { PT _ (TS _ 8) }
  'as' { PT _ (TS _ 9) }
  'codata' { PT _ (TS _ 10) }
  'coprotocol' { PT _ (TS _ 11) }
  'data' { PT _ (TS _ 12) }
  'defn' { PT _ (TS _ 13) }
  'do' { PT _ (TS _ 14) }
  'else' { PT _ (TS _ 15) }
  'fold' { PT _ (TS _ 16) }
  'fun' { PT _ (TS _ 17) }
  'if' { PT _ (TS _ 18) }
  'in' { PT _ (TS _ 19) }
  'into' { PT _ (TS _ 20) }
  'let' { PT _ (TS _ 21) }
  'neg' { PT _ (TS _ 22) }
  'of' { PT _ (TS _ 23) }
  'on' { PT _ (TS _ 24) }
  'plug' { PT _ (TS _ 25) }
  'potato' { PT _ (TS _ 26) }
  'proc' { PT _ (TS _ 27) }
  'protocol' { PT _ (TS _ 28) }
  'race' { PT _ (TS _ 29) }
  'switch' { PT _ (TS _ 30) }
  'then' { PT _ (TS _ 31) }
  'unfold' { PT _ (TS _ 32) }
  'where' { PT _ (TS _ 33) }
  'with' { PT _ (TS _ 34) }
  '{' { PT _ (TS _ 35) }
  '|' { PT _ (TS _ 36) }
  '}' { PT _ (TS _ 37) }
  L_quoted { PT _ (TL $$) }
  L_PInteger { PT _ (T_PInteger _) }
  L_PDouble { PT _ (T_PDouble _) }
  L_PChar { PT _ (T_PChar _) }
  L_PString { PT _ (T_PString _) }
  L_Par { PT _ (T_Par _) }
  L_Tensor { PT _ (T_Tensor _) }
  L_LBracket { PT _ (T_LBracket _) }
  L_RBracket { PT _ (T_RBracket _) }
  L_LSquareBracket { PT _ (T_LSquareBracket _) }
  L_RSquareBracket { PT _ (T_RSquareBracket _) }
  L_NullPattern { PT _ (T_NullPattern _) }
  L_Colon { PT _ (T_Colon _) }
  L_Infixl1op { PT _ (T_Infixl1op _) }
  L_Infixl2op { PT _ (T_Infixl2op _) }
  L_Infixl3op { PT _ (T_Infixl3op _) }
  L_Infixl4op { PT _ (T_Infixl4op _) }
  L_Infixl5op { PT _ (T_Infixl5op _) }
  L_Infixl6op { PT _ (T_Infixl6op _) }
  L_Infixr7op { PT _ (T_Infixr7op _) }
  L_Infixl8op { PT _ (T_Infixl8op _) }
  L_Close { PT _ (T_Close _) }
  L_Halt { PT _ (T_Halt _) }
  L_Get { PT _ (T_Get _) }
  L_Put { PT _ (T_Put _) }
  L_HCase { PT _ (T_HCase _) }
  L_HPut { PT _ (T_HPut _) }
  L_Split { PT _ (T_Split _) }
  L_Fork { PT _ (T_Fork _) }
  L_ChId { PT _ (T_ChId _) }
  L_Case { PT _ (T_Case _) }
  L_UIdent { PT _ (T_UIdent _) }
  L_PIdent { PT _ (T_PIdent _) }
  L_UPIdent { PT _ (T_UPIdent _) }

%%

String  :: { String }
String   : L_quoted { $1 }

PInteger :: { Language.AbsMPL.PInteger}
PInteger  : L_PInteger { Language.AbsMPL.PInteger (mkPosToken $1) }

PDouble :: { Language.AbsMPL.PDouble}
PDouble  : L_PDouble { Language.AbsMPL.PDouble (mkPosToken $1) }

PChar :: { Language.AbsMPL.PChar}
PChar  : L_PChar { Language.AbsMPL.PChar (mkPosToken $1) }

PString :: { Language.AbsMPL.PString}
PString  : L_PString { Language.AbsMPL.PString (mkPosToken $1) }

Par :: { Language.AbsMPL.Par}
Par  : L_Par { Language.AbsMPL.Par (mkPosToken $1) }

Tensor :: { Language.AbsMPL.Tensor}
Tensor  : L_Tensor { Language.AbsMPL.Tensor (mkPosToken $1) }

LBracket :: { Language.AbsMPL.LBracket}
LBracket  : L_LBracket { Language.AbsMPL.LBracket (mkPosToken $1) }

RBracket :: { Language.AbsMPL.RBracket}
RBracket  : L_RBracket { Language.AbsMPL.RBracket (mkPosToken $1) }

LSquareBracket :: { Language.AbsMPL.LSquareBracket}
LSquareBracket  : L_LSquareBracket { Language.AbsMPL.LSquareBracket (mkPosToken $1) }

RSquareBracket :: { Language.AbsMPL.RSquareBracket}
RSquareBracket  : L_RSquareBracket { Language.AbsMPL.RSquareBracket (mkPosToken $1) }

NullPattern :: { Language.AbsMPL.NullPattern}
NullPattern  : L_NullPattern { Language.AbsMPL.NullPattern (mkPosToken $1) }

Colon :: { Language.AbsMPL.Colon}
Colon  : L_Colon { Language.AbsMPL.Colon (mkPosToken $1) }

Infixl1op :: { Language.AbsMPL.Infixl1op}
Infixl1op  : L_Infixl1op { Language.AbsMPL.Infixl1op (mkPosToken $1) }

Infixl2op :: { Language.AbsMPL.Infixl2op}
Infixl2op  : L_Infixl2op { Language.AbsMPL.Infixl2op (mkPosToken $1) }

Infixl3op :: { Language.AbsMPL.Infixl3op}
Infixl3op  : L_Infixl3op { Language.AbsMPL.Infixl3op (mkPosToken $1) }

Infixl4op :: { Language.AbsMPL.Infixl4op}
Infixl4op  : L_Infixl4op { Language.AbsMPL.Infixl4op (mkPosToken $1) }

Infixl5op :: { Language.AbsMPL.Infixl5op}
Infixl5op  : L_Infixl5op { Language.AbsMPL.Infixl5op (mkPosToken $1) }

Infixl6op :: { Language.AbsMPL.Infixl6op}
Infixl6op  : L_Infixl6op { Language.AbsMPL.Infixl6op (mkPosToken $1) }

Infixr7op :: { Language.AbsMPL.Infixr7op}
Infixr7op  : L_Infixr7op { Language.AbsMPL.Infixr7op (mkPosToken $1) }

Infixl8op :: { Language.AbsMPL.Infixl8op}
Infixl8op  : L_Infixl8op { Language.AbsMPL.Infixl8op (mkPosToken $1) }

Close :: { Language.AbsMPL.Close}
Close  : L_Close { Language.AbsMPL.Close (mkPosToken $1) }

Halt :: { Language.AbsMPL.Halt}
Halt  : L_Halt { Language.AbsMPL.Halt (mkPosToken $1) }

Get :: { Language.AbsMPL.Get}
Get  : L_Get { Language.AbsMPL.Get (mkPosToken $1) }

Put :: { Language.AbsMPL.Put}
Put  : L_Put { Language.AbsMPL.Put (mkPosToken $1) }

HCase :: { Language.AbsMPL.HCase}
HCase  : L_HCase { Language.AbsMPL.HCase (mkPosToken $1) }

HPut :: { Language.AbsMPL.HPut}
HPut  : L_HPut { Language.AbsMPL.HPut (mkPosToken $1) }

Split :: { Language.AbsMPL.Split}
Split  : L_Split { Language.AbsMPL.Split (mkPosToken $1) }

Fork :: { Language.AbsMPL.Fork}
Fork  : L_Fork { Language.AbsMPL.Fork (mkPosToken $1) }

ChId :: { Language.AbsMPL.ChId}
ChId  : L_ChId { Language.AbsMPL.ChId (mkPosToken $1) }

Case :: { Language.AbsMPL.Case}
Case  : L_Case { Language.AbsMPL.Case (mkPosToken $1) }

UIdent :: { Language.AbsMPL.UIdent}
UIdent  : L_UIdent { Language.AbsMPL.UIdent (mkPosToken $1) }

PIdent :: { Language.AbsMPL.PIdent}
PIdent  : L_PIdent { Language.AbsMPL.PIdent (mkPosToken $1) }

UPIdent :: { Language.AbsMPL.UPIdent}
UPIdent  : L_UPIdent { Language.AbsMPL.UPIdent (mkPosToken $1) }

ListPIdent :: { [Language.AbsMPL.PIdent] }
ListPIdent : {- empty -} { [] }
           | PIdent { (:[]) $1 }
           | PIdent ',' ListPIdent { (:) $1 $3 }

MplProg :: { Language.AbsMPL.MplProg }
MplProg : ListMplStmt { Language.AbsMPL.MPL_PROG $1 }

MplStmt :: { Language.AbsMPL.MplStmt }
MplStmt : 'defn' '{' ListMplDefn '}' 'where' '{' ListMplWhere '}' { Language.AbsMPL.MPL_DEFN_STMS_WHERE $3 $7 }
        | 'defn' '{' ListMplDefn '}' { Language.AbsMPL.MPL_DEFN_STMS $3 }
        | MplDefn { Language.AbsMPL.MPL_STMT $1 }

ListMplDefn :: { [Language.AbsMPL.MplDefn] }
ListMplDefn : MplDefn { (:[]) $1 }
            | MplDefn ';' ListMplDefn { (:) $1 $3 }

ListMplStmt :: { [Language.AbsMPL.MplStmt] }
ListMplStmt : {- empty -} { [] }
            | MplStmt ListMplStmt { (:) $1 $2 }

MplWhere :: { Language.AbsMPL.MplWhere }
MplWhere : MplStmt { Language.AbsMPL.MPL_WHERE $1 }

ListMplWhere :: { [Language.AbsMPL.MplWhere] }
ListMplWhere : {- empty -} { [] }
             | MplWhere { (:[]) $1 }
             | MplWhere ';' ListMplWhere { (:) $1 $3 }

MplDefn :: { Language.AbsMPL.MplDefn }
MplDefn : SequentialTypeDefn { Language.AbsMPL.MPL_SEQUENTIAL_TYPE_DEFN $1 }
        | ConcurrentTypeDefn { Language.AbsMPL.MPL_CONCURRENT_TYPE_DEFN $1 }
        | FunctionDefn { Language.AbsMPL.MPL_FUNCTION_DEFN $1 }
        | ProcessDefn { Language.AbsMPL.MPL_PROCESS_DEFN $1 }
        | 'potato' { Language.AbsMPL.MPL_DEFNTEST }

MplType :: { Language.AbsMPL.MplType }
MplType : MplType0 { Language.AbsMPL.MPL_TYPE $1 }

MplType0 :: { Language.AbsMPL.MplType }
MplType0 : MplType1 Par MplType1 { Language.AbsMPL.PAR_TYPE $1 $2 $3 }
         | MplType1 { $1 }

MplType1 :: { Language.AbsMPL.MplType }
MplType1 : MplType2 Tensor MplType2 { Language.AbsMPL.TENSOR_TYPE $1 $2 $3 }
         | MplType2 { $1 }

MplType2 :: { Language.AbsMPL.MplType }
MplType2 : UIdent LBracket ListMplType RBracket { Language.AbsMPL.MPL_UIDENT_ARGS_TYPE $1 $2 $3 $4 }
         | UIdent LBracket ListMplType '|' ListMplType RBracket { Language.AbsMPL.MPL_UIDENT_SEQ_CONC_ARGS_TYPE $1 $2 $3 $5 $6 }
         | UIdent { Language.AbsMPL.MPL_UIDENT_NO_ARGS_TYPE $1 }
         | LBracket RBracket { Language.AbsMPL.MPL_UNIT_TYPE $1 $2 }
         | LBracket MplType RBracket { Language.AbsMPL.MPL_BRACKETED_TYPE $1 $2 $3 }
         | LSquareBracket MplType RSquareBracket { Language.AbsMPL.MPL_LIST_TYPE $1 $2 $3 }
         | LBracket MplType ',' ListTupleListType RBracket { Language.AbsMPL.MPL_TUPLE_TYPE $1 $2 $4 $5 }

TupleListType :: { Language.AbsMPL.TupleListType }
TupleListType : MplType { Language.AbsMPL.TUPLE_LIST_TYPE $1 }

ForallVarList :: { Language.AbsMPL.ForallVarList }
ForallVarList : UIdent { Language.AbsMPL.MPL_SEQ_FUN_TYPE_FORALL_LIST $1 }

ListForallVarList :: { [Language.AbsMPL.ForallVarList] }
ListForallVarList : {- empty -} { [] }
                  | ForallVarList ListForallVarList { (:) $1 $2 }

ListTupleListType :: { [Language.AbsMPL.TupleListType] }
ListTupleListType : TupleListType { (:[]) $1 }
                  | TupleListType ',' ListTupleListType { (:) $1 $3 }

ListMplType :: { [Language.AbsMPL.MplType] }
ListMplType : {- empty -} { [] }
            | MplType { (:[]) $1 }
            | MplType ',' ListMplType { (:) $1 $3 }

SequentialTypeDefn :: { Language.AbsMPL.SequentialTypeDefn }
SequentialTypeDefn : 'data' ListSeqTypeClauseDefn { Language.AbsMPL.DATA_DEFN $2 }
                   | 'codata' ListSeqTypeClauseDefn { Language.AbsMPL.CODATA_DEFN $2 }

SeqTypeClauseDefn :: { Language.AbsMPL.SeqTypeClauseDefn }
SeqTypeClauseDefn : MplType '->' MplType '=' '{' ListSeqTypePhraseDefn '}' { Language.AbsMPL.SEQ_TYPE_CLAUSE $1 $3 $6 }

SeqTypePhraseDefn :: { Language.AbsMPL.SeqTypePhraseDefn }
SeqTypePhraseDefn : ListTypeHandleName '::' ListMplType '->' MplType { Language.AbsMPL.SEQ_TYPE_PHRASE $1 $3 $5 }

ListSeqTypeClauseDefn :: { [Language.AbsMPL.SeqTypeClauseDefn] }
ListSeqTypeClauseDefn : SeqTypeClauseDefn { (:[]) $1 }
                      | SeqTypeClauseDefn 'and' ListSeqTypeClauseDefn { (:) $1 $3 }

ListSeqTypePhraseDefn :: { [Language.AbsMPL.SeqTypePhraseDefn] }
ListSeqTypePhraseDefn : {- empty -} { [] }
                      | SeqTypePhraseDefn { (:[]) $1 }
                      | SeqTypePhraseDefn ';' ListSeqTypePhraseDefn { (:) $1 $3 }

ConcurrentTypeDefn :: { Language.AbsMPL.ConcurrentTypeDefn }
ConcurrentTypeDefn : 'protocol' ListConcurrentTypeClauseDefn { Language.AbsMPL.PROTOCOL_DEFN $2 }
                   | 'coprotocol' ListConcurrentTypeClauseDefn { Language.AbsMPL.COPROTOCOL_DEFN $2 }

ConcurrentTypeClauseDefn :: { Language.AbsMPL.ConcurrentTypeClauseDefn }
ConcurrentTypeClauseDefn : MplType '=>' MplType '=' '{' ListConcurrentTypePhraseDefn '}' { Language.AbsMPL.CONCURRENT_TYPE_CLAUSE $1 $3 $6 }

ConcurrentTypePhraseDefn :: { Language.AbsMPL.ConcurrentTypePhraseDefn }
ConcurrentTypePhraseDefn : ListTypeHandleName '::' MplType '=>' MplType { Language.AbsMPL.CONCURRENT_TYPE_PHRASE $1 $3 $5 }

ListConcurrentTypeClauseDefn :: { [Language.AbsMPL.ConcurrentTypeClauseDefn] }
ListConcurrentTypeClauseDefn : ConcurrentTypeClauseDefn { (:[]) $1 }
                             | ConcurrentTypeClauseDefn 'and' ListConcurrentTypeClauseDefn { (:) $1 $3 }

ListConcurrentTypePhraseDefn :: { [Language.AbsMPL.ConcurrentTypePhraseDefn] }
ListConcurrentTypePhraseDefn : {- empty -} { [] }
                             | ConcurrentTypePhraseDefn { (:[]) $1 }
                             | ConcurrentTypePhraseDefn ';' ListConcurrentTypePhraseDefn { (:) $1 $3 }

TypeHandleName :: { Language.AbsMPL.TypeHandleName }
TypeHandleName : UIdent { Language.AbsMPL.TYPE_HANDLE_NAME $1 }

ListTypeHandleName :: { [Language.AbsMPL.TypeHandleName] }
ListTypeHandleName : TypeHandleName { (:[]) $1 }
                   | TypeHandleName ',' ListTypeHandleName { (:) $1 $3 }

Expr :: { Language.AbsMPL.Expr }
Expr : Expr0 { Language.AbsMPL.EXPR $1 }
     | 'if' Expr 'then' Expr 'else' Expr { Language.AbsMPL.IF_EXPR $2 $4 $6 }
     | 'let' '{' ListLetExprPhrase '}' 'in' Expr { Language.AbsMPL.LET_EXPR $3 $6 }

Expr0 :: { Language.AbsMPL.Expr }
Expr0 : Expr1 Colon Expr0 { Language.AbsMPL.INFIXR0_EXPR $1 $2 $3 }
      | Expr1 { $1 }

Expr1 :: { Language.AbsMPL.Expr }
Expr1 : Expr1 Infixl1op Expr2 { Language.AbsMPL.INFIXL1_EXPR $1 $2 $3 }
      | Expr2 { $1 }

Expr2 :: { Language.AbsMPL.Expr }
Expr2 : Expr2 Infixl2op Expr3 { Language.AbsMPL.INFIXL2_EXPR $1 $2 $3 }
      | Expr3 { $1 }

Expr3 :: { Language.AbsMPL.Expr }
Expr3 : Expr3 Infixl3op Expr4 { Language.AbsMPL.INFIXL3_EXPR $1 $2 $3 }
      | Expr4 { $1 }

Expr4 :: { Language.AbsMPL.Expr }
Expr4 : Expr4 Infixl4op Expr5 { Language.AbsMPL.INFIXL4_EXPR $1 $2 $3 }
      | Expr5 { $1 }

Expr5 :: { Language.AbsMPL.Expr }
Expr5 : Expr5 Infixl5op Expr6 { Language.AbsMPL.INFIXL5_EXPR $1 $2 $3 }
      | Expr6 { $1 }

Expr6 :: { Language.AbsMPL.Expr }
Expr6 : Expr6 Infixl6op Expr7 { Language.AbsMPL.INFIXL6_EXPR $1 $2 $3 }
      | Expr7 { $1 }

Expr7 :: { Language.AbsMPL.Expr }
Expr7 : Expr8 Infixr7op Expr7 { Language.AbsMPL.INFIXR7_EXPR $1 $2 $3 }
      | Expr8 { $1 }

Expr8 :: { Language.AbsMPL.Expr }
Expr8 : Expr8 Infixl8op Expr10 { Language.AbsMPL.INFIXL8_EXPR $1 $2 $3 }
      | Expr10 { $1 }

Expr10 :: { Language.AbsMPL.Expr }
Expr10 : LSquareBracket ListExpr RSquareBracket { Language.AbsMPL.LIST_EXPR $1 $2 $3 }
       | PIdent { Language.AbsMPL.VAR_EXPR $1 }
       | PInteger { Language.AbsMPL.INT_EXPR $1 }
       | PString { Language.AbsMPL.STRING_EXPR $1 }
       | PChar { Language.AbsMPL.CHAR_EXPR $1 }
       | PDouble { Language.AbsMPL.DOUBLE_EXPR $1 }
       | LBracket RBracket { Language.AbsMPL.UNIT_EXPR $1 $2 }
       | 'fold' Expr 'of' '{' ListFoldExprPhrase '}' { Language.AbsMPL.FOLD_EXPR $2 $5 }
       | 'unfold' Expr 'of' '{' ListUnfoldExprPhrase '}' { Language.AbsMPL.UNFOLD_EXPR $2 $5 }
       | Case Expr 'of' '{' ListPattExprPhrase '}' { Language.AbsMPL.CASE_EXPR $1 $2 $5 }
       | 'switch' '{' ListSwitchExprPhrase '}' { Language.AbsMPL.SWITCH_EXP $3 }
       | UIdent LBracket ListExpr RBracket { Language.AbsMPL.DESTRUCTOR_CONSTRUCTOR_ARGS_EXPR $1 $2 $3 $4 }
       | UIdent { Language.AbsMPL.DESTRUCTOR_CONSTRUCTOR_NO_ARGS_EXPR $1 }
       | LBracket Expr ',' ListTupleExprList RBracket { Language.AbsMPL.TUPLE_EXPR $1 $2 $4 $5 }
       | PIdent LBracket ListExpr RBracket { Language.AbsMPL.FUN_EXPR $1 $2 $3 $4 }
       | LBracket ListRecordExprPhrase RBracket { Language.AbsMPL.RECORD_EXPR $1 $2 $3 }
       | LBracket Expr RBracket { Language.AbsMPL.BRACKETED_EXPR $1 $2 $3 }

UnfoldExprPhrase :: { Language.AbsMPL.UnfoldExprPhrase }
UnfoldExprPhrase : Pattern 'of' '{' ListFoldExprPhrase '}' { Language.AbsMPL.UNFOLD_EXPR_PHRASE $1 $4 }

ListUnfoldExprPhrase :: { [Language.AbsMPL.UnfoldExprPhrase] }
ListUnfoldExprPhrase : UnfoldExprPhrase { (:[]) $1 }
                     | UnfoldExprPhrase ';' ListUnfoldExprPhrase { (:) $1 $3 }

FoldExprPhrase :: { Language.AbsMPL.FoldExprPhrase }
FoldExprPhrase : UIdent Colon ListPattern '->' Expr { Language.AbsMPL.FOLD_EXPR_PHRASE $1 $2 $3 $5 }

ListFoldExprPhrase :: { [Language.AbsMPL.FoldExprPhrase] }
ListFoldExprPhrase : FoldExprPhrase { (:[]) $1 }
                   | FoldExprPhrase ';' ListFoldExprPhrase { (:) $1 $3 }

LetExprPhrase :: { Language.AbsMPL.LetExprPhrase }
LetExprPhrase : MplStmt { Language.AbsMPL.LET_EXPR_PHRASE $1 }

ListLetExprPhrase :: { [Language.AbsMPL.LetExprPhrase] }
ListLetExprPhrase : LetExprPhrase { (:[]) $1 }
                  | LetExprPhrase ';' ListLetExprPhrase { (:) $1 $3 }

TupleExprList :: { Language.AbsMPL.TupleExprList }
TupleExprList : Expr { Language.AbsMPL.TUPLE_EXPR_LIST $1 }

ListTupleExprList :: { [Language.AbsMPL.TupleExprList] }
ListTupleExprList : TupleExprList { (:[]) $1 }
                  | TupleExprList ',' ListTupleExprList { (:) $1 $3 }

RecordExprPhrase :: { Language.AbsMPL.RecordExprPhrase }
RecordExprPhrase : UIdent ':=' PattExprPhrase { Language.AbsMPL.RECORD_EXPR_HIGHER_ORDER_PHRASE $1 $3 }

ListRecordExprPhrase :: { [Language.AbsMPL.RecordExprPhrase] }
ListRecordExprPhrase : RecordExprPhrase { (:[]) $1 }
                     | RecordExprPhrase ',' ListRecordExprPhrase { (:) $1 $3 }

SwitchExprPhrase :: { Language.AbsMPL.SwitchExprPhrase }
SwitchExprPhrase : Expr '->' Expr { Language.AbsMPL.SWITCH_EXPR_PHRASE $1 $3 }

ListSwitchExprPhrase :: { [Language.AbsMPL.SwitchExprPhrase] }
ListSwitchExprPhrase : SwitchExprPhrase { (:[]) $1 }
                     | SwitchExprPhrase ';' ListSwitchExprPhrase { (:) $1 $3 }

ListExpr :: { [Language.AbsMPL.Expr] }
ListExpr : {- empty -} { [] }
         | Expr { (:[]) $1 }
         | Expr ',' ListExpr { (:) $1 $3 }

PattExprPhrase :: { Language.AbsMPL.PattExprPhrase }
PattExprPhrase : ListPattern '->' Expr { Language.AbsMPL.PATTERN_TO_EXPR $1 $3 }

Pattern :: { Language.AbsMPL.Pattern }
Pattern : Pattern0 { Language.AbsMPL.PATTERN $1 }

ListPattern :: { [Language.AbsMPL.Pattern] }
ListPattern : {- empty -} { [] }
            | Pattern { (:[]) $1 }
            | Pattern ',' ListPattern { (:) $1 $3 }

Pattern0 :: { Language.AbsMPL.Pattern }
Pattern0 : Pattern1 Colon Pattern0 { Language.AbsMPL.LIST_COLON_PATTERN $1 $2 $3 }
         | Pattern1 { $1 }

Pattern1 :: { Language.AbsMPL.Pattern }
Pattern1 : UIdent LBracket ListPattern RBracket { Language.AbsMPL.CONSTRUCTOR_PATTERN_ARGS $1 $2 $3 $4 }
         | UIdent { Language.AbsMPL.CONSTRUCTOR_PATTERN_NO_ARGS $1 }
         | LBracket RBracket { Language.AbsMPL.UNIT_PATTERN $1 $2 }
         | LBracket ListDestructorPatternPhrase RBracket { Language.AbsMPL.RECORD_PATTERN $1 $2 $3 }
         | LSquareBracket ListPattern RSquareBracket { Language.AbsMPL.LIST_PATTERN $1 $2 $3 }
         | LBracket Pattern ',' ListTupleListPattern RBracket { Language.AbsMPL.TUPLE_PATTERN $1 $2 $4 $5 }
         | PIdent { Language.AbsMPL.VAR_PATTERN $1 }
         | String { Language.AbsMPL.STR_PATTERN $1 }
         | PInteger { Language.AbsMPL.INT_PATTERN $1 }
         | NullPattern { Language.AbsMPL.NULL_PATTERN $1 }
         | LBracket Pattern RBracket { Language.AbsMPL.BRACKETED_PATTERN $1 $2 $3 }

TupleListPattern :: { Language.AbsMPL.TupleListPattern }
TupleListPattern : Pattern { Language.AbsMPL.TUPLE_LIST_PATTERN $1 }

ListTupleListPattern :: { [Language.AbsMPL.TupleListPattern] }
ListTupleListPattern : TupleListPattern { (:[]) $1 }
                     | TupleListPattern ',' ListTupleListPattern { (:) $1 $3 }

DestructorPatternPhrase :: { Language.AbsMPL.DestructorPatternPhrase }
DestructorPatternPhrase : UIdent ':=' Pattern { Language.AbsMPL.DESTRUCTOR_PATTERN_PHRASE $1 $3 }

ListDestructorPatternPhrase :: { [Language.AbsMPL.DestructorPatternPhrase] }
ListDestructorPatternPhrase : DestructorPatternPhrase { (:[]) $1 }
                            | DestructorPatternPhrase ',' ListDestructorPatternPhrase { (:) $1 $3 }

FunctionDefn :: { Language.AbsMPL.FunctionDefn }
FunctionDefn : 'fun' PIdent '::' ListMplType '->' MplType '=' '{' ListPattExprPhrase '}' { Language.AbsMPL.TYPED_FUNCTION_DEFN $2 $4 $6 $9 }
             | 'fun' PIdent '=' '{' ListPattExprPhrase '}' { Language.AbsMPL.FUNCTION_DEFN $2 $5 }

ListPattExprPhrase :: { [Language.AbsMPL.PattExprPhrase] }
ListPattExprPhrase : PattExprPhrase { (:[]) $1 }
                   | PattExprPhrase ';' ListPattExprPhrase { (:) $1 $3 }

ProcessDefn :: { Language.AbsMPL.ProcessDefn }
ProcessDefn : 'proc' PIdent '::' ListMplType '|' ListMplType '=>' ListMplType '=' '{' ListProcessPhrase '}' { Language.AbsMPL.TYPED_PROCESS_DEFN $2 $4 $6 $8 $11 }
            | 'proc' PIdent '=' '{' ListProcessPhrase '}' { Language.AbsMPL.PROCESS_DEFN $2 $5 }

ProcessPhrase :: { Language.AbsMPL.ProcessPhrase }
ProcessPhrase : ListPattern '|' ListPIdent '=>' ListPIdent '->' ProcessCommandsBlock { Language.AbsMPL.PROCESS_PHRASE $1 $3 $5 $7 }

ListProcessPhrase :: { [Language.AbsMPL.ProcessPhrase] }
ListProcessPhrase : ProcessPhrase { (:[]) $1 }
                  | ProcessPhrase ';' ListProcessPhrase { (:) $1 $3 }

ProcessCommandsBlock :: { Language.AbsMPL.ProcessCommandsBlock }
ProcessCommandsBlock : 'do' '{' ListProcessCommand '}' { Language.AbsMPL.PROCESS_COMMANDS_DO_BLOCK $3 }
                     | ProcessCommand { Language.AbsMPL.PROCESS_COMMANDS_SINGLE_COMMAND_BLOCK $1 }

ListProcessCommand :: { [Language.AbsMPL.ProcessCommand] }
ListProcessCommand : ProcessCommand { (:[]) $1 }
                   | ProcessCommand ';' ListProcessCommand { (:) $1 $3 }

ProcessCommand :: { Language.AbsMPL.ProcessCommand }
ProcessCommand : PIdent LBracket ListExpr '|' ListPIdent '=>' ListPIdent RBracket { Language.AbsMPL.PROCESS_RUN $1 $2 $3 $5 $7 $8 }
               | Close PIdent { Language.AbsMPL.PROCESS_CLOSE $1 $2 }
               | Halt PIdent { Language.AbsMPL.PROCESS_HALT $1 $2 }
               | Get Pattern 'on' PIdent { Language.AbsMPL.PROCESS_GET $1 $2 $4 }
               | Put Expr 'on' PIdent { Language.AbsMPL.PROCESS_PUT $1 $2 $4 }
               | HCase PIdent 'of' '{' ListHCasePhrase '}' { Language.AbsMPL.PROCESS_HCASE $1 $2 $5 }
               | HPut UIdent 'on' PIdent { Language.AbsMPL.PROCESS_HPUT $1 $2 $4 }
               | Split PIdent 'into' ListSplitChannel { Language.AbsMPL.PROCESS_SPLIT $1 $2 $4 }
               | Fork PIdent 'as' '{' ListForkPhrase '}' { Language.AbsMPL.PROCESS_FORK $1 $2 $5 }
               | PIdent ChId PIdent { Language.AbsMPL.PROCESS_ID $1 $2 $3 }
               | PIdent ChId 'neg' PIdent { Language.AbsMPL.PROCESS_NEG $1 $2 $4 }
               | 'race' '{' ListRacePhrase '}' { Language.AbsMPL.PROCESS_RACE $3 }
               | 'plug' '{' ListPlugPhrase '}' { Language.AbsMPL.PROCESS_PLUG $3 }
               | Case Expr 'of' '{' ListProcessCasePhrase '}' { Language.AbsMPL.PROCESS_CASE $1 $2 $5 }
               | 'switch' '{' ListProcessSwitchPhrase '}' { Language.AbsMPL.PROCESS_SWITCH $3 }

HCasePhrase :: { Language.AbsMPL.HCasePhrase }
HCasePhrase : UIdent '->' ProcessCommandsBlock { Language.AbsMPL.HCASE_PHRASE $1 $3 }

ListHCasePhrase :: { [Language.AbsMPL.HCasePhrase] }
ListHCasePhrase : {- empty -} { [] }
                | HCasePhrase { (:[]) $1 }
                | HCasePhrase ';' ListHCasePhrase { (:) $1 $3 }

SplitChannel :: { Language.AbsMPL.SplitChannel }
SplitChannel : PIdent { Language.AbsMPL.SPLIT_CHANNEL $1 }

ListSplitChannel :: { [Language.AbsMPL.SplitChannel] }
ListSplitChannel : SplitChannel { (:[]) $1 }
                 | SplitChannel ',' ListSplitChannel { (:) $1 $3 }

ForkPhrase :: { Language.AbsMPL.ForkPhrase }
ForkPhrase : PIdent '->' ProcessCommandsBlock { Language.AbsMPL.FORK_PHRASE $1 $3 }
           | PIdent 'with' ListForkChannel '->' ProcessCommandsBlock { Language.AbsMPL.FORK_WITH_PHRASE $1 $3 $5 }

ListForkPhrase :: { [Language.AbsMPL.ForkPhrase] }
ListForkPhrase : ForkPhrase { (:[]) $1 }
               | ForkPhrase ';' ListForkPhrase { (:) $1 $3 }

ForkChannel :: { Language.AbsMPL.ForkChannel }
ForkChannel : PIdent { Language.AbsMPL.FORK_CHANNEL $1 }

ListForkChannel :: { [Language.AbsMPL.ForkChannel] }
ListForkChannel : {- empty -} { [] }
                | ForkChannel { (:[]) $1 }
                | ForkChannel ';' ListForkChannel { (:) $1 $3 }

RacePhrase :: { Language.AbsMPL.RacePhrase }
RacePhrase : PIdent '->' ProcessCommandsBlock { Language.AbsMPL.RACE_PHRASE $1 $3 }

ListRacePhrase :: { [Language.AbsMPL.RacePhrase] }
ListRacePhrase : {- empty -} { [] }
               | RacePhrase { (:[]) $1 }
               | RacePhrase ';' ListRacePhrase { (:) $1 $3 }

PlugPhrase :: { Language.AbsMPL.PlugPhrase }
PlugPhrase : ProcessCommandsBlock { Language.AbsMPL.PLUG_PHRASE $1 }
           | ListPIdent '=>' ListPIdent '->' ProcessCommandsBlock { Language.AbsMPL.PLUG_PHRASE_AS $1 $3 $5 }

ListPlugPhrase :: { [Language.AbsMPL.PlugPhrase] }
ListPlugPhrase : PlugPhrase { (:[]) $1 }
               | PlugPhrase ';' ListPlugPhrase { (:) $1 $3 }

ProcessCasePhrase :: { Language.AbsMPL.ProcessCasePhrase }
ProcessCasePhrase : Pattern '->' ProcessCommandsBlock { Language.AbsMPL.PROCESS_CASE_PHRASE $1 $3 }

ListProcessCasePhrase :: { [Language.AbsMPL.ProcessCasePhrase] }
ListProcessCasePhrase : ProcessCasePhrase { (:[]) $1 }
                      | ProcessCasePhrase ';' ListProcessCasePhrase { (:) $1 $3 }

ProcessSwitchPhrase :: { Language.AbsMPL.ProcessSwitchPhrase }
ProcessSwitchPhrase : Expr '->' ProcessCommandsBlock { Language.AbsMPL.PROCESS_SWITCH_PHRASE $1 $3 }

ListProcessSwitchPhrase :: { [Language.AbsMPL.ProcessSwitchPhrase] }
ListProcessSwitchPhrase : ProcessSwitchPhrase { (:[]) $1 }
                        | ProcessSwitchPhrase ';' ListProcessSwitchPhrase { (:) $1 $3 }
{

happyError :: [Token] -> Either String a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer = tokens
}

