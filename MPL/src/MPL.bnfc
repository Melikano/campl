-- Entry point of the parser
entrypoints MplProg ;

-- comments
comment "--" ;
comment "{-" "-}" ;

-- layout (white space sensitive indentation)
layout "defn", "where", "=", "let", "of", "switch", "do", "as", "race", "plug" ;
layout stop "in" ;
-- layout stop "where" ;

-- ====================================================================
--  MPL tokens
-- ====================================================================

position token PInteger (["-"] digit | digit) digit* ;

position token Par {"(+)"} ;
position token Tensor {"(*)"} ;

position token LBracket '(' ;
position token RBracket ')' ;

position token LSquareBracket '[' ;
position token RSquareBracket ']' ;

position token NullPattern '_' ;

position token Colon ':' ;

-- token Infixr0op ({":"});
-- the reason we don't use this is because ":"
-- is somewhat amgbiuous in the sense that it is used
-- both as cons, and as a seperator for fold phrases
-- Instead, we have a Colon token (as above) and use that
-- whereever we require a colon
position token Infixl1op ({"||"});
position token Infixl2op ({"&&"});
position token Infixl3op ({"=="}|{"/="}|'<'|'>'|{"<="}|{">="});
position token Infixl4op ({"++"}) ;
position token Infixl5op ('+'|'-');
position token Infixl6op ('*'|'/' | '%');
position token Infixr7op ('^') ;
position token Infixl8op ({"!!"}) ;

position token Close {"close"} ;
position token Halt {"halt"} ;
position token Get {"get"} ;
position token Put {"put"} ;
position token HCase {"hcase"} ;
position token HPut {"hput"} ;
position token Split {"split"} ;
position token Fork {"fork"} ;
position token ChId {"|=|"} ;

position token Case {"case"} ;

-- old version without hashtag
-- position token UIdent (upper (letter | digit | '_')*) ;
position token UIdent (('#'upper | upper) (letter | digit | '_')*) ;
position token PIdent letter (letter | digit | '_' | '\'')* ;
position token UPIdent (letter | upper) (letter | digit | '_' | '\'')* ;


separator PIdent "," ;

-- ====================================================================
--  MPL Top level phrases
-- ====================================================================

MPL_PROG . MplProg ::= [MplStmt] ;


MPL_DEFN_STMS_WHERE . MplStmt ::= "defn" "{" [MplDefn] "}" "where" "{" [MplWhere] "}" ;
MPL_DEFN_STMS       . MplStmt ::= "defn" "{" [MplDefn] "}"  ;
MPL_STMT            . MplStmt ::= MplDefn ;

separator nonempty MplDefn ";" ;
separator MplStmt "" ;

MPL_WHERE  . MplWhere ::= MplStmt ;
separator MplWhere ";" ;

-- ====================================================================
--  MPL definitions
-- ====================================================================

-- add type aliases later
MPL_SEQUENTIAL_TYPE_DEFN . MplDefn ::= SequentialTypeDefn ;
MPL_CONCURRENT_TYPE_DEFN . MplDefn ::= ConcurrentTypeDefn ;
MPL_FUNCTION_DEFN        . MplDefn ::= FunctionDefn ;
MPL_PROCESS_DEFN         . MplDefn ::= ProcessDefn ;

MPL_DEFNTEST . MplDefn ::= "potato" ;

-- ====================================================================
--  MPL type 
-- ====================================================================
-- MPL_CONCURRENT_TYPE     . MplType ::= ConcurrentType ;

MPL_TYPE          . MplType ::= MplType0 ;

-- Concurrent types follows... Tensor binds tighter than par
PAR_TYPE          . MplType0 ::= MplType1 Par MplType1;
_                 . MplType0 ::= MplType1 ;

TENSOR_TYPE       . MplType1 ::= MplType2 Tensor MplType2;
_                 . MplType1 ::= MplType2 ;

-- Sequential types / user defined types / type variables follow..
MPL_UIDENT_ARGS_TYPE             . MplType2 ::= UIdent LBracket [MplType] RBracket ;
MPL_UIDENT_SEQ_CONC_ARGS_TYPE    . MplType2 ::= UIdent LBracket [MplType] "|" [MplType] RBracket ;
MPL_UIDENT_NO_ARGS_TYPE . MplType2 ::= UIdent ;
MPL_UNIT_TYPE           . MplType2 ::= LBracket RBracket ;
MPL_BRACKETED_TYPE      . MplType2 ::= LBracket MplType RBracket ;
MPL_LIST_TYPE           . MplType2 ::= LSquareBracket MplType RSquareBracket ;
MPL_TUPLE_TYPE          . MplType2 ::= LBracket MplType "," [TupleListType] RBracket ;

internal MPL_SEQ_ARROW_TYPE  . MplType2 ::= "forall" [ForallVarList] "." [MplType] "->" MplType ;
internal MPL_CONC_ARROW_TYPE . MplType2 ::= "forall" [ForallVarList] "." [MplType] "|" [MplType] "=>" [MplType] ;

TUPLE_LIST_TYPE . TupleListType ::= MplType ;

MPL_SEQ_FUN_TYPE_FORALL_LIST . ForallVarList ::= UIdent ;
separator ForallVarList " " ;

separator nonempty TupleListType "," ;

-- Note: MPL_UIDENT_ARGS_TYPE / MPL_UIDENT_NO_ARGS_TYPE can be used to 
-- define concurrent types TopBot and Neg respectively
-- Moreover, MPL_UIDENT_NO_ARGS_TYPE doubles as a type variable.

separator MplType  "," ;

-- ====================================================================
--  MPL Sequential type definitions
-- ====================================================================

DATA_DEFN   . SequentialTypeDefn ::= "data" [SeqTypeClauseDefn] ;
CODATA_DEFN . SequentialTypeDefn ::= "codata" [SeqTypeClauseDefn] ;

SEQ_TYPE_CLAUSE . SeqTypeClauseDefn ::= MplType "->" MplType "=" "{" [ SeqTypePhraseDefn ]"}" ;
SEQ_TYPE_PHRASE . SeqTypePhraseDefn ::= [TypeHandleName] "::" [MplType] "->" MplType ;

separator nonempty SeqTypeClauseDefn "and" ;
separator SeqTypePhraseDefn ";" ; 

-- ====================================================================
--  MPL Concurrent type definitions (similar to sequential...)
-- ====================================================================

PROTOCOL_DEFN   . ConcurrentTypeDefn ::= "protocol" [ConcurrentTypeClauseDefn] ;
COPROTOCOL_DEFN . ConcurrentTypeDefn ::= "coprotocol" [ConcurrentTypeClauseDefn] ;

CONCURRENT_TYPE_CLAUSE . ConcurrentTypeClauseDefn ::= MplType "=>" MplType "=" "{" [ ConcurrentTypePhraseDefn ]"}" ;
CONCURRENT_TYPE_PHRASE . ConcurrentTypePhraseDefn ::= [TypeHandleName] "::" MplType "=>" MplType ;

separator nonempty ConcurrentTypeClauseDefn "and" ;
separator ConcurrentTypePhraseDefn ";" ;

TYPE_HANDLE_NAME . TypeHandleName ::= UIdent ;
separator nonempty TypeHandleName "," ;

-- ====================================================================
--  MPL Expr definition
-- ====================================================================
EXPR                        . Expr  ::= Expr0 ;
internal TYPED_EXPR         . Expr  ::=  Expr "::" MplType  ;
-- TODO -- not totally sure about this IF and LET precedence?
-- ASK THE OTHER DEVELOPER ABOUT THIS
IF_EXPR   . Expr  ::= "if" Expr "then"  Expr  "else"  Expr ;
LET_EXPR  . Expr  ::= "let" "{" [LetExprPhrase] "}" "in" Expr ;

INFIXR0_EXPR . Expr0 ::=  Expr1 Colon Expr0 ;
_            . Expr0 ::=  Expr1  ;

INFIXL1_EXPR . Expr1 ::=  Expr1 Infixl1op Expr2 ;
_            . Expr1 ::=  Expr2  ;

INFIXL2_EXPR . Expr2 ::=  Expr2 Infixl2op Expr3 ;
_            . Expr2 ::=  Expr3  ;

INFIXL3_EXPR . Expr3 ::=  Expr3 Infixl3op Expr4 ;
_            . Expr3 ::=  Expr4  ;

INFIXL4_EXPR . Expr4 ::=  Expr4 Infixl4op Expr5 ;
_            . Expr4 ::=  Expr5  ;

INFIXL5_EXPR . Expr5 ::=  Expr5 Infixl5op Expr6 ;
_            . Expr5 ::=  Expr6  ;

INFIXL6_EXPR . Expr6 ::=  Expr6 Infixl6op Expr7 ;
_            . Expr6 ::=  Expr7  ;

INFIXR7_EXPR . Expr7 ::=  Expr8 Infixr7op Expr7 ;
_            . Expr7 ::=  Expr8  ;


INFIXL8_EXPR . Expr8 ::= Expr8 Infixl8op Expr10 ;
_            . Expr8 ::= Expr10 ;

-- Not too sure how to get this IF and LET precedence working!
-- Problems of shift reduce errors, so we force explicit bracketing
-- when nesting...
-- IF_EXPR          . Expr9  ::= "if" Expr "then"  Expr  "else"  Expr ;
-- LET_EXPR         . Expr9  ::= "let" "{" [LetExprPhrase] "}" "in" Expr ;
-- _                . Expr9  ::= Expr10 ;

LIST_EXPR        . Expr10 ::= LSquareBracket [Expr] RSquareBracket ;
VAR_EXPR         . Expr10 ::= PIdent ;
INT_EXPR         . Expr10 ::= PInteger ;
STRING_EXPR      . Expr10 ::= String ;
CHAR_EXPR        . Expr10 ::= Char ;
DOUBLE_EXPR      . Expr10 ::= Double ;
UNIT_EXPR        . Expr10 ::= LBracket RBracket ;

FOLD_EXPR        . Expr10 ::= "fold" Expr "of" "{" [FoldExprPhrase] "}" ;
UNFOLD_EXPR      . Expr10 ::= "unfold" Expr "of" "{" [UnfoldExprPhrase] "}" ;
CASE_EXPR        . Expr10 ::= Case Expr "of" "{" [PattExprPhrase] "}" ;
SWITCH_EXP       . Expr10 ::= "switch" "{" [SwitchExprPhrase] "}" ;


DESTRUCTOR_CONSTRUCTOR_ARGS_EXPR    . Expr10 ::= UIdent LBracket [Expr] RBracket ;
DESTRUCTOR_CONSTRUCTOR_NO_ARGS_EXPR . Expr10 ::= UIdent ;
TUPLE_EXPR       . Expr10 ::= LBracket Expr "," [TupleExprList] RBracket ;
FUN_EXPR         . Expr10 ::= PIdent LBracket [Expr] RBracket ;
RECORD_EXPR      . Expr10 ::= LBracket [RecordExprPhrase] RBracket ;

BRACKETED_EXPR   . Expr10 ::= LBracket Expr RBracket ;

UNFOLD_EXPR_PHRASE.    UnfoldExprPhrase ::= Pattern "of" "{" [FoldExprPhrase] "}"  ;
separator nonempty UnfoldExprPhrase ";" ;

FOLD_EXPR_PHRASE.    FoldExprPhrase ::= UIdent Colon [Pattern]  "->"  Expr   ;
separator nonempty FoldExprPhrase ";" ;

LET_EXPR_PHRASE . LetExprPhrase ::= MplStmt ; 
separator nonempty LetExprPhrase ";" ;

TUPLE_EXPR_LIST . TupleExprList ::= Expr ;
separator nonempty TupleExprList "," ;

-- TODO a fairly major refactor is needed to get the RECORD_EXPR_PHRASE to not
-- give us reduce/reduce conflicts.. Ideally, would make a PattExprPhrase
-- have a rule like [AlmightParsingRule] "->" AlmightParsingRule where  
-- AlmightParsingRule is a rule for both patterns and expressions
-- and resolve ambiguities later of what a pattern and an expression is later...

-- BUT, this will still generate a shift/reduce error because we have
-- a list of RecordExprPhrase when this is called. I think (give more thought later..)
-- since the patterns are separated by commas and the RecordExprPhrase is also separted 
-- by commas we get the shift/reduce error. A solution would be to separate one of them 
-- by another character (e.g. "."), or to make the AlmightParsingRule even more almighty
-- and include ":=" as an operator and resolve more ambiguities later...
internal RECORD_EXPR_PHRASE     . RecordExprPhrase ::= UIdent ":=" Expr ;
RECORD_EXPR_HIGHER_ORDER_PHRASE . RecordExprPhrase ::= UIdent ":=" PattExprPhrase ;


separator nonempty RecordExprPhrase "," ;

SWITCH_EXPR_PHRASE . SwitchExprPhrase ::= Expr "->" Expr ;
separator nonempty SwitchExprPhrase ";" ;

separator Expr "," ;


-- ====================================================================
--  MPL Pattern expression definition
-- ====================================================================

PATTERN_TO_EXPR . PattExprPhrase ::= [Pattern] "->" Expr ;

PATTERN                 . Pattern ::= Pattern0 ;
internal TYPED_PATTERN  . Pattern ::= Pattern "::" MplType ;
separator Pattern "," ;

LIST_COLON_PATTERN       . Pattern0 ::= Pattern1 Colon Pattern0 ;
_                        . Pattern0 ::= Pattern1 ;

CONSTRUCTOR_PATTERN_ARGS    . Pattern1 ::=  UIdent LBracket [Pattern] RBracket ;
CONSTRUCTOR_PATTERN_NO_ARGS . Pattern1 ::=  UIdent ;
UNIT_PATTERN                . Pattern1 ::= LBracket RBracket ; 
RECORD_PATTERN              . Pattern1 ::= LBracket [DestructorPatternPhrase] RBracket ;
LIST_PATTERN                . Pattern1 ::=  LSquareBracket [Pattern] RSquareBracket ;
TUPLE_PATTERN               . Pattern1 ::=  LBracket Pattern "," [TupleListPattern] RBracket ;
VAR_PATTERN                 . Pattern1 ::=  PIdent ;
STR_PATTERN                 . Pattern1 ::=  String ;
INT_PATTERN                 . Pattern1 ::=  PInteger ;
NULL_PATTERN                . Pattern1 ::=  NullPattern ;
BRACKETED_PATTERN           . Pattern1 ::=  LBracket Pattern RBracket ;

TUPLE_LIST_PATTERN . TupleListPattern ::= Pattern ;
separator nonempty TupleListPattern "," ;

DESTRUCTOR_PATTERN_PHRASE . DestructorPatternPhrase ::=  UIdent ":=" Pattern ;
separator nonempty DestructorPatternPhrase "," ;


-- ====================================================================
--  MPL Function definition
-- ====================================================================

internal INTERNAL_TYPED_FUNCTION_DEFN . FunctionDefn ::= 
    "fun" PIdent "::" MplType
        "=" "{" [ PattExprPhrase ]"}" ;

TYPED_FUNCTION_DEFN . FunctionDefn ::= 
    "fun" PIdent "::" [MplType] "->" MplType 
        "=" "{" [ PattExprPhrase ]"}" ;

FUNCTION_DEFN       . FunctionDefn ::= 
    "fun" PIdent "=" "{" [ PattExprPhrase ]"}" ;

separator nonempty PattExprPhrase ";" ;

-- ====================================================================
--  MPL Process definition
-- ====================================================================

TYPED_PROCESS_DEFN . ProcessDefn ::= 
    "proc" PIdent "::" [MplType]  "|" [MplType] "=>" [MplType]
                   "=" "{" [ProcessPhrase] "}" ;

internal INTERNAL_TYPED_PROCESS_DEFN . ProcessDefn ::= 
    "proc" PIdent "::" MplType
                   "=" "{" [ProcessPhrase] "}" ;

PROCESS_DEFN . ProcessDefn ::= 
    "proc" PIdent "=" "{" [ProcessPhrase] "}" ;

PROCESS_PHRASE . ProcessPhrase ::=
    [Pattern]  "|" [PIdent] "=>" [PIdent] "->" ProcessCommandsBlock ;
separator nonempty ProcessPhrase ";" ;


PROCESS_COMMANDS_DO_BLOCK             . ProcessCommandsBlock ::= 
    "do" "{" [ ProcessCommand ] "}" ;
PROCESS_COMMANDS_SINGLE_COMMAND_BLOCK . ProcessCommandsBlock ::= 
    ProcessCommand  ;

separator nonempty ProcessCommand ";" ;

-----------------------------
-- Old version without as many tokens..
-----------------------------
-- PROCESS_RUN   .   ProcessCommand ::= PIdent LBracket [Expr] "|" [PIdent] "=>" [PIdent] RBracket ;
-- PROCESS_CLOSE .   ProcessCommand ::= "close" PIdent ;
-- PROCESS_HALT  .   ProcessCommand ::= "halt" PIdent ;
-- 
-- PROCESS_GET   .   ProcessCommand ::= "get" Pattern "on" PIdent ;
-- PROCESS_PUT   .   ProcessCommand ::= "put" Expr "on" PIdent ;
-- 
-- PROCESS_HCASE .   ProcessCommand ::= "hcase" PIdent "of" "{" [HCasePhrase] "}";
-- PROCESS_HPUT  .   ProcessCommand ::= "hput" UIdent "on" PIdent ;
-- 
-- PROCESS_SPLIT . ProcessCommand ::= "split" PIdent "into" [ SplitChannel ] ;
-- PROCESS_FORK  . ProcessCommand ::= "fork" PIdent "as" "{" [ ForkPhrase ] "}" ;
-- 
-- PROCESS_ID    . ProcessCommand ::= PIdent "|=|" PIdent ;
-- PROCESS_NEG   . ProcessCommand ::= PIdent "|=|" "neg" PIdent ;
-- 
-- PROCESS_RACE  . ProcessCommand ::= "race" "{" [ RacePhrase ] "}" ;
-- 
-- PROCESS_PLUG    . ProcessCommand ::= "plug" "{" [ PlugPhrase ] "}" ;
-- -- "plug" is a layout word, so we can't use this rule unforunately...
-- -- PROCESS_PLUG_AS . ProcessCommand ::= "plug"  [PIdent] "as" "{" [ PlugPhrase ] "}" ;
-- 
-- PROCESS_CASE   . ProcessCommand ::= "case" Expr "of" "{" [ProcessCasePhrase] "}";
-- PROCESS_SWITCH . ProcessCommand ::= "switch" "{" [ProcessSwitchPhrase] "}";
-----------------------------

PROCESS_RUN   .   ProcessCommand ::= PIdent LBracket [Expr] "|" [PIdent] "=>" [PIdent] RBracket ;
PROCESS_CLOSE .   ProcessCommand ::= Close PIdent ;
PROCESS_HALT  .   ProcessCommand ::= Halt PIdent ;

PROCESS_GET   .   ProcessCommand ::= Get Pattern "on" PIdent ;
PROCESS_PUT   .   ProcessCommand ::= Put Expr "on" PIdent ;

PROCESS_HCASE .   ProcessCommand ::= HCase PIdent "of" "{" [HCasePhrase] "}";
PROCESS_HPUT  .   ProcessCommand ::= HPut UIdent "on" PIdent ;

PROCESS_SPLIT . ProcessCommand ::= Split PIdent "into" [ SplitChannel ] ;
PROCESS_FORK  . ProcessCommand ::= Fork PIdent "as" "{" [ ForkPhrase ] "}" ;

PROCESS_ID    . ProcessCommand ::= PIdent ChId PIdent ;
PROCESS_NEG   . ProcessCommand ::= PIdent ChId "neg" PIdent ;

PROCESS_RACE  . ProcessCommand ::= "race" "{" [ RacePhrase ] "}" ;

PROCESS_PLUG    . ProcessCommand ::= "plug" "{" [ PlugPhrase ] "}" ;
-- "plug" is a layout word, so we can't use this rule unforunately...
-- PROCESS_PLUG_AS . ProcessCommand ::= "plug"  [PIdent] "as" "{" [ PlugPhrase ] "}" ;

PROCESS_CASE   . ProcessCommand ::= Case Expr "of" "{" [ProcessCasePhrase] "}";
PROCESS_SWITCH . ProcessCommand ::= "switch" "{" [ProcessSwitchPhrase] "}";




HCASE_PHRASE . HCasePhrase ::= UIdent "->" ProcessCommandsBlock ;
separator HCasePhrase ";" ;

SPLIT_CHANNEL . SplitChannel ::= PIdent ;
separator nonempty SplitChannel "," ;

FORK_PHRASE . ForkPhrase ::= PIdent "->" ProcessCommandsBlock ;
FORK_WITH_PHRASE . ForkPhrase ::= PIdent "with" [ForkChannel] "->" ProcessCommandsBlock ;
separator nonempty ForkPhrase ";" ;

FORK_CHANNEL . ForkChannel ::= PIdent ;
separator ForkChannel ";" ;

RACE_PHRASE . RacePhrase ::= PIdent "->" ProcessCommandsBlock ;
separator RacePhrase ";" ;

-- PLUG_PHRASE    . PlugPhrase ::= ProcessCommandsBlock ;
-- PLUG_PHRASE_AS . PlugPhrase ::= "with" [PIdent] "->" ProcessCommandsBlock ;
PLUG_PHRASE    . PlugPhrase ::= ProcessCommandsBlock ;
PLUG_PHRASE_AS . PlugPhrase ::= [PIdent] "=>" [PIdent] "->" ProcessCommandsBlock ;
separator nonempty PlugPhrase ";" ;

PROCESS_CASE_PHRASE . ProcessCasePhrase ::=  Pattern "->" ProcessCommandsBlock ;
separator ProcessCasePhrase ";" ;

PROCESS_SWITCH_PHRASE . ProcessSwitchPhrase ::= Expr "->" ProcessCommandsBlock ;
separator nonempty ProcessSwitchPhrase ";" ;
