-- Entry point of the parser
entrypoints MplProg ;

-- comments
comment "--" ;
comment "{-" "-}" ;

-- layout (white space sensitive indentation)
layout "defn", "where", "=", "let", "of", "switch", "do", "as", "race", "plug" ;
layout stop "in" ;
-- layout stop "where" ;

-- ====================================================================
--  MPL tokens
-- ====================================================================
position token UIdent (upper (letter | digit | '_')*) ;
position token PIdent letter (letter | digit | '_' | '\'')* ;
position token PInteger (["-"] digit | digit) digit* ;

-- token Infixr0op ({":"});
-- the reason we don't use this is because ":"
-- is somewhat amgbiuous in the sense that it is used
-- both as cons, and as a seperator for fold phrases
-- Instead, we explicitily write ":" when needed
token Infixl1op ({"||"});
token Infixl2op ({"&&"});
token Infixl3op ({"=="}|{"/="}|'<'|'>'|{"<="}|{">="});
token Infixl4op ({"++"}) ;
token Infixl5op ('+'|'-');
token Infixl6op ('*'|'/' | '%');
token Infixr7op ('^') ;
token Infixl8op ({"!!"}) ;

separator PIdent "," ;

-- ====================================================================
--  MPL Top level phrases
-- ====================================================================

MPL_PROG . MplProg ::= [MplStmt] ;


MPL_DEFN_STMS_WHERE . MplStmt ::= "defn" "{" [MplDefn] "}" "where" "{" [MplStmt] "}" ;
MPL_DEFN_STMS       . MplStmt ::= "defn" "{" [MplDefn] "}"  ;
MPL_STMT            . MplStmt ::= MplDefn ;

separator nonempty MplDefn ";" ;
separator MplStmt "" ;

-- ====================================================================
--  MPL definitions
-- ====================================================================

-- add type aliases later
MPL_SEQUENTIAL_TYPE_DEFN . MplDefn ::= SequentialTypeDefn ;
MPL_CONCURRENT_TYPE_DEFN . MplDefn ::= ConcurrentTypeDefn ;
MPL_FUNCTION_DEFN        . MplDefn ::= FunctionDefn ;
MPL_PROCESS_DEFN         . MplDefn ::= ProcessDefn ;

MPLDEFNTEST . MplDefn ::= "potato" ;

-- ====================================================================
--  MPL type 
-- ====================================================================
-- MPL_CONCURRENT_TYPE     . MplType ::= ConcurrentType ;

MPL_TYPE          . MplType ::= MplType0 ;

-- Concurrent types follows... Tensor binds tighter than par
PAR_TYPE          . MplType0 ::= MplType1 "(+)" MplType1;
_                 . MplType0 ::= MplType1 ;

TENSOR_TYPE       . MplType1 ::= MplType2 "(*)" MplType2;
_                 . MplType1 ::= MplType2 ;

GETPUT_TYPE       . MplType2 ::= UIdent"(" MplType "|" MplType ")" ;
_                 . MplType2 ::= MplType3 ;

-- Sequential types / user defined types / type variables follow..
MPL_UIDENT_ARGS_TYPE    . MplType3 ::= UIdent "(" [MplType] ")" ;
MPL_UIDENT_NO_ARGS_TYPE . MplType3 ::= UIdent ;
MPL_UNIT_TYPE           . MplType3 ::= "(" ")" ;
MPL_BRACKETED_TYPE      . MplType3 ::= "(" MplType ")" ;
MPL_LIST_TYPE           . MplType3 ::= "[" MplType "]" ;
MPL_TUPLE_TYPE          . MplType3 ::= "(" MplType "," [TupleListType] ")" ;

TUPLE_LIST_TYPE . TupleListType ::= MplType ;

separator nonempty TupleListType "," ;

-- Note: MPL_UIDENT_ARGS_TYPE / MPL_UIDENT_NO_ARGS_TYPE can be used to 
-- define concurrent types TopBot and Neg respectively
-- Moreover, MPL_UIDENT_NO_ARGS_TYPE doubles as a type variable.

separator MplType  "," ;

-- ====================================================================
--  MPL Sequential type definitions
-- ====================================================================

DATA_DEFN   . SequentialTypeDefn ::= "data" [SeqTypeClauseDefn] ;
CODATA_DEFN . SequentialTypeDefn ::= "codata" [SeqTypeClauseDefn] ;

SEQ_TYPE_CLAUSE . SeqTypeClauseDefn ::= MplType "->" MplType "=" "{" [ SeqTypePhraseDefn ]"}" ;
SEQ_TYPE_PHRASE . SeqTypePhraseDefn ::= [TypeHandleName] "::" [MplType] "->" MplType ;

separator nonempty SeqTypeClauseDefn "and" ;
separator SeqTypePhraseDefn ";" ; 

-- ====================================================================
--  MPL Concurrent type definitions (similar to sequential...)
-- ====================================================================

PROTOCOL_DEFN   . ConcurrentTypeDefn ::= "protocol" [ConcurrentTypeClauseDefn] ;
COPROTOCOL_DEFN . ConcurrentTypeDefn ::= "coprotocol" [ConcurrentTypeClauseDefn] ;

CONCURRENT_TYPE_CLAUSE . ConcurrentTypeClauseDefn ::= MplType "=>" MplType "=" "{" [ ConcurrentTypePhraseDefn ]"}" ;
CONCURRENT_TYPE_PHRASE . ConcurrentTypePhraseDefn ::= [TypeHandleName] "::" MplType "=>" MplType ;

separator nonempty ConcurrentTypeClauseDefn "and" ;
separator ConcurrentTypePhraseDefn ";" ;

TYPE_HANDLE_NAME . TypeHandleName ::= UIdent ;
separator nonempty TypeHandleName "," ;

-- ====================================================================
--  MPL Expr definition
-- ====================================================================
EXPR      . Expr  ::= Expr0 ;
-- TODO -- not totally sure about this IF and LET precedence?
-- ASK THE OTHER DEVELOPER ABOUT THIS
IF_EXPR   . Expr  ::= "if" Expr "then"  Expr  "else"  Expr ;
LET_EXPR  . Expr  ::= "let" "{" [LetExprPhrase] "}" "in" Expr ;

INFIXR0_EXPR . Expr0 ::=  Expr1 ":" Expr0 ;
_           . Expr0 ::=  Expr1  ;

INFIXL1_EXPR . Expr1 ::=  Expr1 Infixl1op Expr2 ;
_           . Expr1 ::=  Expr2  ;

INFIXL2_EXPR . Expr2 ::=  Expr2 Infixl2op Expr3 ;
_           . Expr2 ::=  Expr3  ;

INFIXL3_EXPR . Expr3 ::=  Expr3 Infixl3op Expr4 ;
_           . Expr3 ::=  Expr4  ;

INFIXL4_EXPR . Expr4 ::=  Expr4 Infixl4op Expr5 ;
_           . Expr4 ::=  Expr5  ;

INFIXL5_EXPR . Expr5 ::=  Expr5 Infixl5op Expr6 ;
_           . Expr5 ::=  Expr6  ;

INFIXL6_EXPR . Expr6 ::=  Expr6 Infixl6op Expr7 ;
_           . Expr6 ::=  Expr7  ;

INFIXR7_EXPR . Expr7 ::=  Expr8 Infixr7op Expr7 ;
_           . Expr7 ::=  Expr8  ;


INFIXL8_EXPR . Expr8 ::= Expr8 Infixl8op Expr10 ;
_            . Expr8 ::= Expr10 ;

-- Not too sure how to get this IF and LET precedence working!
-- Problems of shift reduce errors, so we force explicit bracketing
-- when nesting...
-- IF_EXPR          . Expr9  ::= "if" Expr "then"  Expr  "else"  Expr ;
-- LET_EXPR         . Expr9  ::= "let" "{" [LetExprPhrase] "}" "in" Expr ;
-- _                . Expr9  ::= Expr10 ;

LIST_EXPR        . Expr10 ::= "[" [Expr] "]" ;
VAR_EXPR         . Expr10 ::= PIdent ;
INT_EXPR         . Expr10 ::= PInteger ;
STRING_EXPR      . Expr10 ::= String ;
CHAR_EXPR        . Expr10 ::= Char ;
DOUBLE_EXPR      . Expr10 ::= Double ;
UNIT_EXPR        . Expr10 ::= "(" ")" ;

FOLD_EXPR        . Expr10 ::= "fold" PIdent "of" "{" [FoldExprPhrase] "}" ;
UNFOLD_EXPR      . Expr10 ::= "unfold" PIdent "of" "{" [UnfoldExprPhrase] "}" ;
CASE_EXPR        . Expr10 ::= "case" Expr "of" "{" [PattExprPhrase] "}" ;
SWITCH_EXP       . Expr10 ::= "switch" "{" [SwitchExprPhrase] "}" ;


DESTRUCTOR_CONSTRUCTOR_ARGS_EXPR    . Expr10 ::= UIdent "(" [Expr] ")" ;
DESTRUCTOR_CONSTRUCTOR_NO_ARGS_EXPR . Expr10 ::= UIdent ;
TUPLE_EXPR       . Expr10 ::= "(" Expr "," [TupleExprList] ")" ;
FUN_EXPR         . Expr10 ::= PIdent "(" [Expr] ")" ;
RECORD_EXPR      . Expr10 ::= "(" [RecordExprPhrase] ")" ;

_                . Expr10 ::= "(" Expr ")" ;

UNFOLD_EXPR_PHRASE.    UnfoldExprPhrase ::= Expr "of" "{" [FoldExprPhrase] "}"  ;
separator UnfoldExprPhrase ";" ;

FOLD_EXPR_PHRASE.    FoldExprPhrase ::= UIdent ":"  [PIdent]  "->"  Expr   ;
separator FoldExprPhrase ";" ;

LET_EXPR_PHRASE . LetExprPhrase ::= MplStmt ; 
separator nonempty LetExprPhrase ";" ;

TUPLE_EXPR_LIST . TupleExprList ::= Expr ;
separator nonempty TupleExprList "," ;

RECORD_EXPR_PHRASE . RecordExprPhrase ::= UIdent ":=" Expr ;
separator nonempty RecordExprPhrase "," ;

SWITCH_EXPR_PHRASE . SwitchExprPhrase ::= Expr "->" Expr ;
separator nonempty SwitchExprPhrase ";" ;

separator Expr "," ;


-- ====================================================================
--  MPL Pattern expression definition
-- ====================================================================

PATTERN_TO_EXPR . PattExprPhrase ::= [Pattern] "->" Expr ;

PATTERN  . Pattern ::= Pattern0 ;
separator Pattern "," ;

LIST_COLON_PATTERN       . Pattern0 ::= Pattern1 ":" Pattern0 ;
_                        . Pattern0 ::= Pattern1 ;

CONSTRUCTOR_PATTERN_ARGS    . Pattern1 ::=  UIdent "(" [Pattern] ")" ;
CONSTRUCTOR_PATTERN_NO_ARGS . Pattern1 ::=  UIdent ;
UNIT_PATTERN                . Pattern1 ::= "(" ")" ; 
RECORD_PATTERN              . Pattern1 ::= "(" DestructorPatternPhrase "," [DestructorPatternPhrase] ")";
LIST_PATTERN                . Pattern1 ::=  "[" [Pattern] "]" ;
TUPLE_PATTERN               . Pattern1 ::=  "(" Pattern "," [TupleListPattern] ")" ;
VAR_PATTERN                 . Pattern1 ::=  PIdent ;
STR_PATTERN                 . Pattern1 ::=  String ;
INT_PATTERN                 . Pattern1 ::=  PInteger ;
NULL_PATTERN                . Pattern1 ::=  "_" ;
_                           . Pattern1 ::=  "(" Pattern ")" ;

TUPLE_LIST_PATTERN . TupleListPattern ::= Pattern ;
separator nonempty TupleListPattern "," ;

DESTRUCTOR_PATTERN_PHRASE . DestructorPatternPhrase ::=  UIdent ":=" Pattern ;
separator nonempty DestructorPatternPhrase "," ;


-- ====================================================================
--  MPL Function definition
-- ====================================================================
TYPED_FUNCTION_DEFN . FunctionDefn ::= 
    "fun" PIdent "::" [MplType] "->" MplType 
        "=" "{" [ PattExprPhrase ]"}" ;

FUNCTION_DEFN       . FunctionDefn ::= 
    "fun" PIdent "=" "{" [ PattExprPhrase ]"}" ;

separator nonempty PattExprPhrase ";" ;

-- ====================================================================
--  MPL Process definition
-- ====================================================================

TYPED_PROCESS_DEFN . ProcessDefn ::= 
    "proc" PIdent "::" [MplType]  "|" [MplType] "=>" [MplType]
                   "=" "{" [ProcessPhrase] "}" ;

PROCESS_DEFN . ProcessDefn ::= 
    "proc" PIdent "=" "{" [ProcessPhrase] "}" ;

PROCESS_PHRASE . ProcessPhrase ::=
    [Pattern]  "|" [PIdent] "=>" [PIdent] "->" ProcessCommandsBlock ;
separator ProcessPhrase ";" ;


PROCESS_COMMANDS_DO_BLOCK             . ProcessCommandsBlock ::= 
    "do" "{" [ ProcessCommand ] "}" ;
PROCESS_COMMANDS_SINGLE_COMMAND_BLOCK . ProcessCommandsBlock ::= 
    ProcessCommand  ;

separator ProcessCommand ";" ;

PROCESS_RUN   .   ProcessCommand ::= PIdent "(" [Expr] "|" [PIdent] "=>" [PIdent] ")" ;
PROCESS_CLOSE .   ProcessCommand ::= "close" PIdent ;
PROCESS_HALT  .   ProcessCommand ::= "halt" PIdent ;

PROCESS_GET   .   ProcessCommand ::= "get" PIdent "on" PIdent ;
PROCESS_PUT   .   ProcessCommand ::= "put" Expr "on" PIdent ;

PROCESS_HCASE .   ProcessCommand ::= "hcase" PIdent "of" "{" [HCasePhrase] "}";
PROCESS_HPUT  .   ProcessCommand ::= "hput" UIdent "on" PIdent ;

PROCESS_SPLIT . ProcessCommand ::= "split" PIdent "into" [PIdent] ;
PROCESS_FORK  . ProcessCommand ::= "fork" PIdent "as" "{" [ ForkPhrase ] "}" ;

PROCESS_ID    . ProcessCommand ::= PIdent "|=|" PIdent ;
PROCESS_NEG   . ProcessCommand ::= PIdent "|=|" "neg" PIdent ;

PROCESS_RACE  . ProcessCommand ::= "race" "{" [ RacePhrase ] "}" ;

PROCESS_PLUG    . ProcessCommand ::= "plug" "{" [ PlugPhrase ] "}" ;
-- "plug" is a layout word, so we can't use this rule unforunately...
-- PROCESS_PLUG_AS . ProcessCommand ::= "plug"  [PIdent] "as" "{" [ PlugPhrase ] "}" ;

PROCESS_CASE   . ProcessCommand ::= "case" Expr "of" "{" [ProcessCasePhrase] "}";
PROCESS_SWITCH . ProcessCommand ::= "switch" "{" [ProcessSwitchPhrase] "}";




HCASE_PHRASE . HCasePhrase ::= UIdent "->" ProcessCommandsBlock ;
separator HCasePhrase ";" ;

FORK_WITH_PHRASE . ForkPhrase ::= PIdent "with" [PIdent] "->" ProcessCommandsBlock ;
FORK_PHRASE . ForkPhrase ::= PIdent "->" ProcessCommandsBlock ;
separator ForkPhrase ";" ;

RACE_PHRASE . RacePhrase ::= PIdent "->" ProcessCommandsBlock ;
separator RacePhrase ";" ;

PLUG_PHRASE    . PlugPhrase ::= ProcessCommandsBlock ;
-- PLUG_PHRASE_AS . PlugPhrase ::= "with" [PIdent] "->" ProcessCommandsBlock ;
separator PlugPhrase ";" ;

PROCESS_CASE_PHRASE . ProcessCasePhrase ::=  [Pattern] "->" ProcessCommandsBlock ;
separator ProcessCasePhrase ";" ;

PROCESS_SWITCH_PHRASE . ProcessSwitchPhrase ::= Expr "->" ProcessCommandsBlock ;
separator ProcessSwitchPhrase ";" ;
