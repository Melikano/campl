{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
module MplPasses.Parser.ParseMplPattern where

import qualified MplPasses.Parser.BnfcParse as B

import Optics 
import MplAST.MplCore
import MplAST.MplParsed
import MplPasses.Parser.ParseErrors 
import MplPasses.Parser.ParseUtils 

import Control.Monad.Writer
import Control.Monad.Except

import qualified Data.List.NonEmpty as NE
import Data.List.NonEmpty (NonEmpty (..))

import Control.Arrow
import Control.Applicative
import Text.Read

parseBnfcPattern :: 
    BnfcParse B.Pattern (MplPattern MplParsed)
parseBnfcPattern (B.PATTERN p) = parseBnfcPattern p
parseBnfcPattern (B.CONSTRUCTOR_PATTERN_ARGS ident _ patts _) = do
    patts' <- traverse parseBnfcPattern patts
    return $ _PConstructor # ((), toTermIdentP ident, patts' )
parseBnfcPattern (B.CONSTRUCTOR_PATTERN_NO_ARGS ident) = 
   return $ _PConstructor # ((), toTermIdentP ident, [] )

parseBnfcPattern (B.RECORD_PATTERN l as r) = do
    as' <- traverse f as
    return $ _PRecord # (toSpanLocation l r, NE.fromList as')
  where
    f (B.DESTRUCTOR_PATTERN_PHRASE ident patt) = 
        ((), toTermIdentP ident,) <$> parseBnfcPattern patt

parseBnfcPattern (B.VAR_PATTERN a) = 
   return $ _PVar # ((), toTermIdentP a)

parseBnfcPattern (B.LIST_COLON_PATTERN a colon b) = do
    a' <- parseBnfcPattern a
    b' <- parseBnfcPattern b
    return $ _PListCons # (toLocation colon, a', b')
parseBnfcPattern (B.UNIT_PATTERN lbr rbr) = 
    return $ _PUnit # toLocation lbr 
parseBnfcPattern (B.LIST_PATTERN lbr patts rbr) = do
    patts' <- traverse parseBnfcPattern patts
    return $ _PList # (toSpanLocation lbr rbr, patts')

parseBnfcPattern (B.TUPLE_PATTERN lbr p0 (p1:ps) rbr) = do
    p0' <- parseBnfcPattern p0
    p1' <- f p1
    ps' <- traverse f ps
    return $ _PTuple # (toSpanLocation lbr rbr, (p0',p1', ps'))
  where
    f (B.TUPLE_LIST_PATTERN patt) = parseBnfcPattern patt
parseBnfcPattern (B.TUPLE_PATTERN lbr p0 _  rbr) = error "Internal bnfc parsing error -- tuple list is empty"

-- TODO: we need char patterns!
parseBnfcPattern (B.STR_PATTERN (B.PString (loc, str))) = 
    return $ _PString # (toLocation loc, init $ tail str)

parseBnfcPattern (B.CHAR_PATTERN v) = 
    case pCharToLocationChar v of
        Just n -> return $ _PChar # n
        Nothing -> tell [_InvalidChar # toTermIdentP v] >> throwError ()

parseBnfcPattern (B.INT_PATTERN v) = 
    case pIntegerToLocationInt v of
        Just n -> return $ _PInt # n
        Nothing -> tell [_InvalidInt # toTermIdentP v] >> throwError ()

parseBnfcPattern (B.NULL_PATTERN n) = 
    return $ _PNull # toLocation n

parseBnfcPattern (B.BRACKETED_PATTERN _ pattern _) = parseBnfcPattern pattern

parseBnfcPattern (B.TYPED_PATTERN _ _) = error "B.TYPED_PATTERN cannot be generated by BNFC"

