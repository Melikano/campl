-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module Language.ParAMPL where
import Language.AbsAMPL
import Language.LexAMPL
import Language.ErrM

}

%name pAMPLCODE AMPLCODE
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '#' { PT _ (TS _ 1) }
  '%cohandles' { PT _ (TS _ 2) }
  '%constructors' { PT _ (TS _ 3) }
  '%destructors' { PT _ (TS _ 4) }
  '%functions' { PT _ (TS _ 5) }
  '%handles' { PT _ (TS _ 6) }
  '%include' { PT _ (TS _ 7) }
  '%processes' { PT _ (TS _ 8) }
  '(' { PT _ (TS _ 9) }
  ')' { PT _ (TS _ 10) }
  ',' { PT _ (TS _ 11) }
  '-' { PT _ (TS _ 12) }
  '->' { PT _ (TS _ 13) }
  '.' { PT _ (TS _ 14) }
  ':' { PT _ (TS _ 15) }
  ':=' { PT _ (TS _ 16) }
  ';' { PT _ (TS _ 17) }
  '=' { PT _ (TS _ 18) }
  '=>' { PT _ (TS _ 19) }
  '[' { PT _ (TS _ 20) }
  ']' { PT _ (TS _ 21) }
  'as' { PT _ (TS _ 22) }
  'else' { PT _ (TS _ 23) }
  'into' { PT _ (TS _ 24) }
  'of' { PT _ (TS _ 25) }
  'on' { PT _ (TS _ 26) }
  'then' { PT _ (TS _ 27) }
  'with' { PT _ (TS _ 28) }
  '{' { PT _ (TS _ 29) }
  '|' { PT _ (TS _ 30) }
  '}' { PT _ (TS _ 31) }
  L_quoted { PT _ (TL $$) }
  L_integ  { PT _ (TI $$) }
  L_Store { PT _ (T_Store _) }
  L_Load { PT _ (T_Load _) }
  L_Ret { PT _ (T_Ret _) }
  L_Call { PT _ (T_Call _) }
  L_ConstInt { PT _ (T_ConstInt _) }
  L_ConstChar { PT _ (T_ConstChar _) }
  L_ConstString { PT _ (T_ConstString _) }
  L_ToStr { PT _ (T_ToStr _) }
  L_ToInt { PT _ (T_ToInt _) }
  L_And { PT _ (T_And _) }
  L_Or { PT _ (T_Or _) }
  L_Append { PT _ (T_Append _) }
  L_Unstring { PT _ (T_Unstring _) }
  L_LeqI { PT _ (T_LeqI _) }
  L_EqI { PT _ (T_EqI _) }
  L_Leqc { PT _ (T_Leqc _) }
  L_Eqc { PT _ (T_Eqc _) }
  L_Leqs { PT _ (T_Leqs _) }
  L_Eqs { PT _ (T_Eqs _) }
  L_ConcatS { PT _ (T_ConcatS _) }
  L_Add { PT _ (T_Add _) }
  L_Subtract { PT _ (T_Subtract _) }
  L_Mul { PT _ (T_Mul _) }
  L_Quot { PT _ (T_Quot _) }
  L_Rem { PT _ (T_Rem _) }
  L_Cons { PT _ (T_Cons _) }
  L_Case { PT _ (T_Case _) }
  L_If { PT _ (T_If _) }
  L_Rec { PT _ (T_Rec _) }
  L_Get { PT _ (T_Get _) }
  L_Put { PT _ (T_Put _) }
  L_Hput { PT _ (T_Hput _) }
  L_Hcase { PT _ (T_Hcase _) }
  L_Split { PT _ (T_Split _) }
  L_Fork { PT _ (T_Fork _) }
  L_Plug { PT _ (T_Plug _) }
  L_Run { PT _ (T_Run _) }
  L_Race { PT _ (T_Race _) }
  L_Close { PT _ (T_Close _) }
  L_Halt { PT _ (T_Halt _) }
  L_Ch_Id { PT _ (T_Ch_Id _) }
  L_Main_run { PT _ (T_Main_run _) }
  L_BTrue { PT _ (T_BTrue _) }
  L_BFalse { PT _ (T_BFalse _) }
  L_Character { PT _ (T_Character _) }
  L_UIdent { PT _ (T_UIdent _) }
  L_PIdent { PT _ (T_PIdent _) }
  L_PInteger { PT _ (T_PInteger _) }
  L_IIdent { PT _ (T_IIdent _) }

%%

String  :: { String }
String   : L_quoted {  $1 }

Integer :: { Integer }
Integer  : L_integ  { (read ( $1)) :: Integer }

Store :: { Store}
Store  : L_Store { Store (mkPosToken $1)}

Load :: { Load}
Load  : L_Load { Load (mkPosToken $1)}

Ret :: { Ret}
Ret  : L_Ret { Ret (mkPosToken $1)}

Call :: { Call}
Call  : L_Call { Call (mkPosToken $1)}

ConstInt :: { ConstInt}
ConstInt  : L_ConstInt { ConstInt (mkPosToken $1)}

ConstChar :: { ConstChar}
ConstChar  : L_ConstChar { ConstChar (mkPosToken $1)}

ConstString :: { ConstString}
ConstString  : L_ConstString { ConstString (mkPosToken $1)}

ToStr :: { ToStr}
ToStr  : L_ToStr { ToStr (mkPosToken $1)}

ToInt :: { ToInt}
ToInt  : L_ToInt { ToInt (mkPosToken $1)}

And :: { And}
And  : L_And { And (mkPosToken $1)}

Or :: { Or}
Or  : L_Or { Or (mkPosToken $1)}

Append :: { Append}
Append  : L_Append { Append (mkPosToken $1)}

Unstring :: { Unstring}
Unstring  : L_Unstring { Unstring (mkPosToken $1)}

LeqI :: { LeqI}
LeqI  : L_LeqI { LeqI (mkPosToken $1)}

EqI :: { EqI}
EqI  : L_EqI { EqI (mkPosToken $1)}

Leqc :: { Leqc}
Leqc  : L_Leqc { Leqc (mkPosToken $1)}

Eqc :: { Eqc}
Eqc  : L_Eqc { Eqc (mkPosToken $1)}

Leqs :: { Leqs}
Leqs  : L_Leqs { Leqs (mkPosToken $1)}

Eqs :: { Eqs}
Eqs  : L_Eqs { Eqs (mkPosToken $1)}

ConcatS :: { ConcatS}
ConcatS  : L_ConcatS { ConcatS (mkPosToken $1)}

Add :: { Add}
Add  : L_Add { Add (mkPosToken $1)}

Subtract :: { Subtract}
Subtract  : L_Subtract { Subtract (mkPosToken $1)}

Mul :: { Mul}
Mul  : L_Mul { Mul (mkPosToken $1)}

Quot :: { Quot}
Quot  : L_Quot { Quot (mkPosToken $1)}

Rem :: { Rem}
Rem  : L_Rem { Rem (mkPosToken $1)}

Cons :: { Cons}
Cons  : L_Cons { Cons (mkPosToken $1)}

Case :: { Case}
Case  : L_Case { Case (mkPosToken $1)}

If :: { If}
If  : L_If { If (mkPosToken $1)}

Rec :: { Rec}
Rec  : L_Rec { Rec (mkPosToken $1)}

Get :: { Get}
Get  : L_Get { Get (mkPosToken $1)}

Put :: { Put}
Put  : L_Put { Put (mkPosToken $1)}

Hput :: { Hput}
Hput  : L_Hput { Hput (mkPosToken $1)}

Hcase :: { Hcase}
Hcase  : L_Hcase { Hcase (mkPosToken $1)}

Split :: { Split}
Split  : L_Split { Split (mkPosToken $1)}

Fork :: { Fork}
Fork  : L_Fork { Fork (mkPosToken $1)}

Plug :: { Plug}
Plug  : L_Plug { Plug (mkPosToken $1)}

Run :: { Run}
Run  : L_Run { Run (mkPosToken $1)}

Race :: { Race}
Race  : L_Race { Race (mkPosToken $1)}

Close :: { Close}
Close  : L_Close { Close (mkPosToken $1)}

Halt :: { Halt}
Halt  : L_Halt { Halt (mkPosToken $1)}

Ch_Id :: { Ch_Id}
Ch_Id  : L_Ch_Id { Ch_Id (mkPosToken $1)}

Main_run :: { Main_run}
Main_run  : L_Main_run { Main_run (mkPosToken $1)}

BTrue :: { BTrue}
BTrue  : L_BTrue { BTrue (mkPosToken $1)}

BFalse :: { BFalse}
BFalse  : L_BFalse { BFalse (mkPosToken $1)}

Character :: { Character}
Character  : L_Character { Character (mkPosToken $1)}

UIdent :: { UIdent}
UIdent  : L_UIdent { UIdent (mkPosToken $1)}

PIdent :: { PIdent}
PIdent  : L_PIdent { PIdent (mkPosToken $1)}

PInteger :: { PInteger}
PInteger  : L_PInteger { PInteger (mkPosToken $1)}

IIdent :: { IIdent}
IIdent  : L_IIdent { IIdent (mkPosToken $1)}

AMPLCODE :: { AMPLCODE }
AMPLCODE : ListAMPL_CONSTRUCTS START { Language.AbsAMPL.Main (reverse $1) $2 }
AMPL_CONSTRUCTS :: { AMPL_CONSTRUCTS }
AMPL_CONSTRUCTS : IMPORT { Language.AbsAMPL.IMPORT_CONSTRUCT $1 }
                | HANDLES { Language.AbsAMPL.HANDLE_CONSTRUCT $1 }
                | COHANDLES { Language.AbsAMPL.COHANDLE_CONSTRUCT $1 }
                | CONSTRUCTORS { Language.AbsAMPL.CONSTRUCTOR_CONSTRUCT $1 }
                | DESTRUCTORS { Language.AbsAMPL.DESTRUCTOR_CONSTRUCT $1 }
                | PROCESSES { Language.AbsAMPL.PROCESSES_CONSTRUCT $1 }
                | FUNCTIONS { Language.AbsAMPL.FUNCTIONS_CONSTRUCT $1 }
ListAMPL_CONSTRUCTS :: { [AMPL_CONSTRUCTS] }
ListAMPL_CONSTRUCTS : {- empty -} { [] }
                    | ListAMPL_CONSTRUCTS AMPL_CONSTRUCTS { flip (:) $1 $2 }
HANDLE_SPEC :: { HANDLE_SPEC }
HANDLE_SPEC : UIdent '=' '{' ListHandle '}' { Language.AbsAMPL.Hand_spec $1 $4 }
Handle :: { Handle }
Handle : UIdent { Language.AbsAMPL.HandName $1 }
ListHANDLE_SPEC :: { [HANDLE_SPEC] }
ListHANDLE_SPEC : {- empty -} { [] }
                | HANDLE_SPEC { (:[]) $1 }
                | HANDLE_SPEC ';' ListHANDLE_SPEC { (:) $1 $3 }
ListHandle :: { [Handle] }
ListHandle : Handle { (:[]) $1 }
           | Handle ';' ListHandle { (:) $1 $3 }
IMPORT :: { IMPORT }
IMPORT : '%include' IIdent { Language.AbsAMPL.Import $2 }
CONSTRUCTORS :: { CONSTRUCTORS }
CONSTRUCTORS : '%constructors' ':' '{' ListSTRUCTOR_SPEC '}' { Language.AbsAMPL.Constructors $4 }
DESTRUCTORS :: { DESTRUCTORS }
DESTRUCTORS : '%destructors' ':' '{' ListSTRUCTOR_SPEC '}' { Language.AbsAMPL.Destructors $4 }
STRUCTOR_SPEC :: { STRUCTOR_SPEC }
STRUCTOR_SPEC : UIdent '=' '{' ListSTRUCT '}' { Language.AbsAMPL.Struct_spec $1 $4 }
STRUCT :: { STRUCT }
STRUCT : UIdent PInteger { Language.AbsAMPL.Struct $1 $2 }
ListSTRUCTOR_SPEC :: { [STRUCTOR_SPEC] }
ListSTRUCTOR_SPEC : {- empty -} { [] }
                  | STRUCTOR_SPEC { (:[]) $1 }
                  | STRUCTOR_SPEC ';' ListSTRUCTOR_SPEC { (:) $1 $3 }
ListSTRUCT :: { [STRUCT] }
ListSTRUCT : STRUCT { (:[]) $1 }
           | STRUCT ';' ListSTRUCT { (:) $1 $3 }
HANDLES :: { HANDLES }
HANDLES : '%handles' ':' '{' ListHANDLE_SPEC '}' { Language.AbsAMPL.Handles $4 }
COHANDLES :: { COHANDLES }
COHANDLES : '%cohandles' ':' '{' ListHANDLE_SPEC '}' { Language.AbsAMPL.Cohandles $4 }
PROCESSES :: { PROCESSES }
PROCESSES : '%processes' ':' '{' ListPROCESS_SPEC '}' { Language.AbsAMPL.Processes $4 }
ListPROCESS_SPEC :: { [PROCESS_SPEC] }
ListPROCESS_SPEC : {- empty -} { [] }
                 | PROCESS_SPEC { (:[]) $1 }
                 | PROCESS_SPEC ';' ListPROCESS_SPEC { (:) $1 $3 }
PROCESS_SPEC :: { PROCESS_SPEC }
PROCESS_SPEC : PIdent '(' ListVars '|' ListPIdent '=>' ListPIdent ')' '=' COMS { Language.AbsAMPL.Process_spec $1 $3 $5 $7 $10 }
Vars :: { Vars }
Vars : PIdent { Language.AbsAMPL.VName $1 }
ListVars :: { [Vars] }
ListVars : {- empty -} { [] }
         | Vars { (:[]) $1 }
         | Vars ',' ListVars { (:) $1 $3 }
FUNCTIONS :: { FUNCTIONS }
FUNCTIONS : '%functions' ':' '{' ListFUNCTION_SPEC '}' { Language.AbsAMPL.Functions $4 }
ListFUNCTION_SPEC :: { [FUNCTION_SPEC] }
ListFUNCTION_SPEC : {- empty -} { [] }
                  | FUNCTION_SPEC { (:[]) $1 }
                  | FUNCTION_SPEC ';' ListFUNCTION_SPEC { (:) $1 $3 }
FUNCTION_SPEC :: { FUNCTION_SPEC }
FUNCTION_SPEC : PIdent '(' ListVars ')' '=' COMS { Language.AbsAMPL.Function_spec $1 $3 $6 }
START :: { START }
START : Main_run CHANNEL_SPEC ':' COMS { Language.AbsAMPL.Start $1 $2 $4 }
      | {- empty -} { Language.AbsAMPL.Start_none }
CHANNEL_SPEC :: { CHANNEL_SPEC }
CHANNEL_SPEC : '(' '|' ListPIdent '=>' ListPIdent ')' { Language.AbsAMPL.Channel_spec $3 $5 }
COMS :: { COMS }
COMS : '{' ListCOM '}' { Language.AbsAMPL.Prog $2 }
ListCOM :: { [COM] }
ListCOM : {- empty -} { [] }
        | COM { (:[]) $1 }
        | COM ';' ListCOM { (:) $1 $3 }
COM :: { COM }
COM : PIdent ':=' COM { Language.AbsAMPL.AC_ASSIGN $1 $3 }
    | Store PIdent { Language.AbsAMPL.AC_STOREf $1 $2 }
    | Load PIdent { Language.AbsAMPL.AC_LOADf $1 $2 }
    | Ret { Language.AbsAMPL.AC_RET $1 }
    | Call PIdent '(' ListPIdent ')' { Language.AbsAMPL.AC_CALLf $1 $2 $4 }
    | ConstInt CInteger { Language.AbsAMPL.AC_INT $1 $2 }
    | ConstChar Character { Language.AbsAMPL.AC_CHAR $1 $2 }
    | ConstString String { Language.AbsAMPL.AC_STRING $1 $2 }
    | ToStr { Language.AbsAMPL.AC_TOSTR $1 }
    | ToInt { Language.AbsAMPL.AC_TOINT $1 }
    | And { Language.AbsAMPL.AC_AND $1 }
    | Or { Language.AbsAMPL.AC_OR $1 }
    | Append { Language.AbsAMPL.AC_APPEND $1 }
    | BTrue { Language.AbsAMPL.AC_TRUE $1 }
    | BFalse { Language.AbsAMPL.AC_FALSE $1 }
    | Unstring { Language.AbsAMPL.AC_UNSTRING $1 }
    | LeqI { Language.AbsAMPL.AC_LEQ $1 }
    | EqI { Language.AbsAMPL.AC_EQ $1 }
    | Leqc { Language.AbsAMPL.AC_LEQC $1 }
    | Eqc { Language.AbsAMPL.AC_EQC $1 }
    | Leqs { Language.AbsAMPL.AC_LEQS $1 }
    | Eqs { Language.AbsAMPL.AC_EQS $1 }
    | ConcatS Integer { Language.AbsAMPL.AC_CONCAT $1 $2 }
    | Add { Language.AbsAMPL.AC_ADD $1 }
    | Subtract { Language.AbsAMPL.AC_SUB $1 }
    | Mul { Language.AbsAMPL.AC_MUL $1 }
    | Quot { Language.AbsAMPL.AC_DIVQ $1 }
    | Rem { Language.AbsAMPL.AC_DIVR $1 }
    | Cons '(' PInteger ',' PInteger ')' { Language.AbsAMPL.AC_CONS $1 $3 $5 }
    | UIdent '.' UIdent { Language.AbsAMPL.AC_STRUCT $1 $3 }
    | UIdent '.' UIdent '(' ListPIdent ')' { Language.AbsAMPL.AC_STRUCTAS $1 $3 $5 }
    | Case PIdent 'of' '{' ListLABELCOMS '}' { Language.AbsAMPL.AC_CASEf $1 $2 $5 }
    | If PIdent 'then' COMS 'else' COMS { Language.AbsAMPL.AC_IF $1 $2 $4 $6 }
    | Rec 'of' '{' ListLABELCOMS '}' { Language.AbsAMPL.AC_RECORDf $1 $4 }
    | UIdent '.' UIdent PIdent { Language.AbsAMPL.AC_DEST $1 $3 $4 }
    | UIdent '.' UIdent '(' ListPIdent ')' PIdent { Language.AbsAMPL.AC_DESTAS $1 $3 $5 $7 }
    | Get PIdent 'on' PIdent { Language.AbsAMPL.AC_GETf $1 $2 $4 }
    | Hput UIdent '.' UIdent 'on' PIdent { Language.AbsAMPL.AC_HPUTf $1 $2 $4 $6 }
    | Hcase PIdent 'of' '{' ListLABELCOMS '}' { Language.AbsAMPL.AC_HCASEf $1 $2 $5 }
    | Put PIdent 'on' PIdent { Language.AbsAMPL.AC_PUTf $1 $2 $4 }
    | Split PIdent 'into' PIdent PIdent { Language.AbsAMPL.AC_SPLITf $1 $2 $4 $5 }
    | Fork PIdent 'as' '{' PIdent 'with' ListPIdent ':' COMS ';' PIdent 'with' ListPIdent ':' COMS '}' { Language.AbsAMPL.AC_FORKf $1 $2 $5 $7 $9 $11 $13 $15 }
    | Plug ListPIdent 'as' '{' 'with' '[' ListPIdent ']' ':' COMS ';' 'with' '[' ListPIdent ']' ':' COMS '}' { Language.AbsAMPL.AC_PLUGf $1 $2 $7 $10 $14 $17 }
    | Run PIdent '(' ListPIdent '|' ListPIdent '=>' ListPIdent ')' { Language.AbsAMPL.AC_RUNf $1 $2 $4 $6 $8 }
    | PIdent Ch_Id PIdent { Language.AbsAMPL.AC_IDF $1 $2 $3 }
    | Race '{' ListRACES '}' { Language.AbsAMPL.AC_RACE $1 $3 }
    | '(' ListPIdent ')' { Language.AbsAMPL.AC_PROD $2 }
    | '#' PInteger '(' PIdent ')' { Language.AbsAMPL.AC_PRODELEM $2 $4 }
    | String { Language.AbsAMPL.AC_EMSG $1 }
    | Close PIdent { Language.AbsAMPL.AC_CLOSEf $1 $2 }
    | Halt PIdent { Language.AbsAMPL.AC_HALTf $1 $2 }
LABELCOMS :: { LABELCOMS }
LABELCOMS : UIdent '.' UIdent ':' COMS { Language.AbsAMPL.Labelcoms1 $1 $3 $5 }
          | UIdent '.' UIdent '(' ListPIdent ')' ':' COMS { Language.AbsAMPL.Labelcoms2 $1 $3 $5 $8 }
ListCOMS :: { [COMS] }
ListCOMS : {- empty -} { [] }
         | COMS { (:[]) $1 }
         | COMS ',' ListCOMS { (:) $1 $3 }
ListLABELCOMS :: { [LABELCOMS] }
ListLABELCOMS : {- empty -} { [] }
              | LABELCOMS { (:[]) $1 }
              | LABELCOMS ';' ListLABELCOMS { (:) $1 $3 }
RACES :: { RACES }
RACES : PIdent '->' COMS { Language.AbsAMPL.Races $1 $3 }
ListRACES :: { [RACES] }
ListRACES : {- empty -} { [] }
          | RACES { (:[]) $1 }
          | RACES ';' ListRACES { (:) $1 $3 }
ListPIdent :: { [PIdent] }
ListPIdent : {- empty -} { [] }
           | PIdent { (:[]) $1 }
           | PIdent ',' ListPIdent { (:) $1 $3 }
CInteger :: { CInteger }
CInteger : PInteger { Language.AbsAMPL.Positive $1 }
         | '-' PInteger { Language.AbsAMPL.Negative $2 }
ListCInteger :: { [CInteger] }
ListCInteger : {- empty -} { [] }
             | CInteger { (:[]) $1 }
             | CInteger ',' ListCInteger { (:) $1 $3 }
{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ id(prToken t) ++ "'"

myLexer = tokens
}

